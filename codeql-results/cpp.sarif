{"$schema":"https://json.schemastore.org/sarif-2.1.0.json","version":"2.1.0","runs":[{"tool":{"driver":{"name":"CodeQL","organization":"GitHub","semanticVersion":"2.22.1","notifications":[{"id":"cli/expected-extracted-files/cpp","name":"cli/expected-extracted-files/cpp","shortDescription":{"text":"Expected extracted files"},"fullDescription":{"text":"Files appearing in the source archive that are expected to be extracted."},"defaultConfiguration":{"enabled":true},"properties":{"tags":["expected-extracted-files","telemetry"],"languageDisplayName":"C++"}},{"id":"codeql-action/zstd-availability","name":"codeql-action/zstd-availability","shortDescription":{"text":"Zstandard availability"},"fullDescription":{"text":"Zstandard availability"},"defaultConfiguration":{"enabled":true}},{"id":"cpp/extractor/summary","name":"cpp/extractor/summary","shortDescription":{"text":"C++ extractor telemetry"},"fullDescription":{"text":"C++ extractor telemetry"},"defaultConfiguration":{"enabled":true}}],"rules":[]},"extensions":[{"name":"codeql/cpp-queries","semanticVersion":"1.4.3+4ece8abc3032a266eb4b9839442d8be5084552ea","notifications":[{"id":"cpp/diagnostics/successfully-extracted-files","name":"cpp/diagnostics/successfully-extracted-files","shortDescription":{"text":"Extracted files"},"fullDescription":{"text":"Lists all files in the source code directory that were extracted."},"defaultConfiguration":{"enabled":true},"properties":{"tags":["successfully-extracted-files"],"description":"Lists all files in the source code directory that were extracted.","id":"cpp/diagnostics/successfully-extracted-files","kind":"diagnostic","name":"Extracted files"}},{"id":"cpp/diagnostics/extraction-warnings","name":"cpp/diagnostics/extraction-warnings","shortDescription":{"text":"Extraction warnings"},"fullDescription":{"text":"List all extraction warnings for files in the source code directory."},"defaultConfiguration":{"enabled":true},"properties":{"description":"List all extraction warnings for files in the source code directory.","id":"cpp/diagnostics/extraction-warnings","kind":"diagnostic","name":"Extraction warnings"}},{"id":"cpp/diagnostics/failed-extractor-invocations","name":"cpp/diagnostics/failed-extractor-invocations","shortDescription":{"text":"Failed extractor invocations"},"fullDescription":{"text":"Gives the command line of compilations for which extraction did not run to completion."},"defaultConfiguration":{"enabled":true},"properties":{"description":"Gives the command line of compilations for which extraction did not run to completion.","id":"cpp/diagnostics/failed-extractor-invocations","kind":"diagnostic","name":"Failed extractor invocations"}}],"rules":[{"id":"cpp/suspicious-add-sizeof","name":"cpp/suspicious-add-sizeof","shortDescription":{"text":"Suspicious add with sizeof"},"fullDescription":{"text":"Explicitly scaled pointer arithmetic expressions can cause buffer overflow conditions if the offset is also implicitly scaled."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Suspicious add with sizeof\nPointer arithmetic in C and C++ is automatically scaled according to the size of the data type. For example, if the type of `p` is `T*` and `sizeof(T) == 4` then the expression `p+1` adds 4 bytes to `p`.\n\nThis query finds code of the form `p + k*sizeof(T)`. Such code is usually a mistake because there is no need to manually scale the offset by `sizeof(T)`.\n\n\n## Recommendation\n1. Whenever possible, use the array subscript operator rather than pointer arithmetic. For example, replace `*(p+k)` with `p[k]`.\n1. Cast to the correct type before using pointer arithmetic. For example, if the type of `p` is `char*` but it really points to an array of type `double[]` then use the syntax `(double*)p + k` to get a pointer to the `k`'th element of the array.\n\n## Example\n\n```cpp\nint example1(int i) {\n  int intArray[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n  int *intPointer = intArray;\n  // BAD: the offset is already automatically scaled by sizeof(int),\n  // so this code will compute the wrong offset.\n  return *(intPointer + (i * sizeof(int)));\n}\n\nint example2(int i) {\n  int intArray[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n  int *intPointer = intArray;\n  // GOOD: the offset is automatically scaled by sizeof(int).\n  return *(intPointer + i);\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-468](https://cwe.mitre.org/data/definitions/468.html).\n","markdown":"# Suspicious add with sizeof\nPointer arithmetic in C and C++ is automatically scaled according to the size of the data type. For example, if the type of `p` is `T*` and `sizeof(T) == 4` then the expression `p+1` adds 4 bytes to `p`.\n\nThis query finds code of the form `p + k*sizeof(T)`. Such code is usually a mistake because there is no need to manually scale the offset by `sizeof(T)`.\n\n\n## Recommendation\n1. Whenever possible, use the array subscript operator rather than pointer arithmetic. For example, replace `*(p+k)` with `p[k]`.\n1. Cast to the correct type before using pointer arithmetic. For example, if the type of `p` is `char*` but it really points to an array of type `double[]` then use the syntax `(double*)p + k` to get a pointer to the `k`'th element of the array.\n\n## Example\n\n```cpp\nint example1(int i) {\n  int intArray[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n  int *intPointer = intArray;\n  // BAD: the offset is already automatically scaled by sizeof(int),\n  // so this code will compute the wrong offset.\n  return *(intPointer + (i * sizeof(int)));\n}\n\nint example2(int i) {\n  int intArray[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n  int *intPointer = intArray;\n  // GOOD: the offset is automatically scaled by sizeof(int).\n  return *(intPointer + i);\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-468](https://cwe.mitre.org/data/definitions/468.html).\n"},"properties":{"tags":["security","external/cwe/cwe-468"],"description":"Explicitly scaled pointer arithmetic expressions\n              can cause buffer overflow conditions if the offset is also\n              implicitly scaled.","id":"cpp/suspicious-add-sizeof","kind":"problem","name":"Suspicious add with sizeof","precision":"high","problem.severity":"warning","security-severity":"8.8"}},{"id":"cpp/insufficient-key-size","name":"cpp/insufficient-key-size","shortDescription":{"text":"Use of a cryptographic algorithm with insufficient key size"},"fullDescription":{"text":"Using cryptographic algorithms with too small a key size can allow an attacker to compromise security."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Use of a cryptographic algorithm with insufficient key size\nUsing cryptographic algorithms with a small key size can leave data vulnerable to being decrypted.\n\nMany cryptographic algorithms provided by cryptography libraries can be configured with key sizes that are vulnerable to brute force attacks. Using such a key size means that an attacker may be able to easily decrypt the encrypted data.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm. Use at least AES-128 or RSA-2048.\n\n\n## Example\nThe following code shows an example of using the `openssl` library to generate an RSA key. When creating a key, you must specify which key size to use. The first example uses 1024 bits, which is not considered sufficient. The second example uses 2048 bits, which is currently considered sufficient.\n\n\n```c\nvoid encrypt_with_openssl(EVP_PKEY_CTX *ctx) {\n\n  // BAD: only 1024 bits for an RSA key\n  EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 1024);\n\n  // GOOD: 2048 bits for an RSA key\n  EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048);\n}\n```\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar2.pdf).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n","markdown":"# Use of a cryptographic algorithm with insufficient key size\nUsing cryptographic algorithms with a small key size can leave data vulnerable to being decrypted.\n\nMany cryptographic algorithms provided by cryptography libraries can be configured with key sizes that are vulnerable to brute force attacks. Using such a key size means that an attacker may be able to easily decrypt the encrypted data.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm. Use at least AES-128 or RSA-2048.\n\n\n## Example\nThe following code shows an example of using the `openssl` library to generate an RSA key. When creating a key, you must specify which key size to use. The first example uses 1024 bits, which is not considered sufficient. The second example uses 2048 bits, which is currently considered sufficient.\n\n\n```c\nvoid encrypt_with_openssl(EVP_PKEY_CTX *ctx) {\n\n  // BAD: only 1024 bits for an RSA key\n  EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 1024);\n\n  // GOOD: 2048 bits for an RSA key\n  EVP_PKEY_CTX_set_rsa_keygen_bits(ctx, 2048);\n}\n```\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar2.pdf).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n"},"properties":{"tags":["security","external/cwe/cwe-326"],"description":"Using cryptographic algorithms with too small a key size can\n              allow an attacker to compromise security.","id":"cpp/insufficient-key-size","kind":"path-problem","name":"Use of a cryptographic algorithm with insufficient key size","precision":"high","problem.severity":"error","security-severity":"7.5"}},{"id":"cpp/tainted-format-string","name":"cpp/tainted-format-string","shortDescription":{"text":"Uncontrolled format string"},"fullDescription":{"text":"Using externally-controlled format strings in printf-style functions can lead to buffer overflows or data representation problems."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Uncontrolled format string\nThe program uses input from the user as a format string for `printf` style functions. This can lead to buffer overflows or data representation problems. An attacker can exploit this weakness to crash the program, disclose information or even execute arbitrary code.\n\nThe results of this rule do not include inputs from the user that are transferred through global variables. Those can be found in the related rule \"Uncontrolled format string (through global variable)\".\n\n\n## Recommendation\nUse constant expressions as the format strings. If you need to print a value from the user, use `printf(\"%s\", value_from_user)`.\n\n\n## Example\n\n```c\n#include <stdio.h>\n\nvoid printWrapper(char *str) {\n\tprintf(str);\n}\n\nint main(int argc, char **argv) {\n\t// This should be avoided\n\tprintf(argv[1]);\n\n\t// This should be avoided too, because it has the same effect\n\tprintWrapper(argv[1]);\n\n\t// This is fine\n\tprintf(\"%s\", argv[1]);\n}\n```\n\n## References\n* CERT C Coding Standard: [FIO30-C. Exclude user input from format strings](https://www.securecoding.cert.org/confluence/display/c/FIO30-C.+Exclude+user+input+from+format+strings).\n* Common Weakness Enumeration: [CWE-134](https://cwe.mitre.org/data/definitions/134.html).\n","markdown":"# Uncontrolled format string\nThe program uses input from the user as a format string for `printf` style functions. This can lead to buffer overflows or data representation problems. An attacker can exploit this weakness to crash the program, disclose information or even execute arbitrary code.\n\nThe results of this rule do not include inputs from the user that are transferred through global variables. Those can be found in the related rule \"Uncontrolled format string (through global variable)\".\n\n\n## Recommendation\nUse constant expressions as the format strings. If you need to print a value from the user, use `printf(\"%s\", value_from_user)`.\n\n\n## Example\n\n```c\n#include <stdio.h>\n\nvoid printWrapper(char *str) {\n\tprintf(str);\n}\n\nint main(int argc, char **argv) {\n\t// This should be avoided\n\tprintf(argv[1]);\n\n\t// This should be avoided too, because it has the same effect\n\tprintWrapper(argv[1]);\n\n\t// This is fine\n\tprintf(\"%s\", argv[1]);\n}\n```\n\n## References\n* CERT C Coding Standard: [FIO30-C. Exclude user input from format strings](https://www.securecoding.cert.org/confluence/display/c/FIO30-C.+Exclude+user+input+from+format+strings).\n* Common Weakness Enumeration: [CWE-134](https://cwe.mitre.org/data/definitions/134.html).\n"},"properties":{"tags":["reliability","security","external/cwe/cwe-134"],"description":"Using externally-controlled format strings in\n              printf-style functions can lead to buffer overflows\n              or data representation problems.","id":"cpp/tainted-format-string","kind":"path-problem","name":"Uncontrolled format string","precision":"high","problem.severity":"warning","security-severity":"9.3"}},{"id":"cpp/cleartext-storage-file","name":"cpp/cleartext-storage-file","shortDescription":{"text":"Cleartext storage of sensitive information in file"},"fullDescription":{"text":"Storing sensitive information in cleartext can expose it to an attacker."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Cleartext storage of sensitive information in file\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored to a file or transmitted over the network. It may be wise to encrypt information before it is put into a buffer that may be readable in memory.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\n\n## Example\nThe following example shows two ways of storing user credentials in a file. In the 'BAD' case, the credentials are simply stored in cleartext. In the 'GOOD' case, the credentials are encrypted before storing them.\n\n\n```c\n#include <sodium.h>\n#include <stdio.h>\n#include <string.h>\n\nvoid writeCredentialsBad(FILE *file, const char *cleartextCredentials) {\n  // BAD: write password to disk in cleartext\n  fputs(cleartextCredentials, file);\n}\n\nint writeCredentialsGood(FILE *file, const char *cleartextCredentials, const unsigned char *key, const unsigned char *nonce) {\n  size_t credentialsLen = strlen(cleartextCredentials);\n  size_t ciphertext_len = crypto_secretbox_MACBYTES + credentialsLen;\n  unsigned char *ciphertext = malloc(ciphertext_len);\n  if (!ciphertext) {\n    logError();\n    return -1;\n  }\n\n  // encrypt the password first\n  if (crypto_secretbox_easy(ciphertext, (const unsigned char *)cleartextCredentials, credentialsLen, nonce, key) != 0) {\n    free(ciphertext);\n    logError();\n    return -1;\n  }\n\n  // GOOD: write encrypted password to disk\n  fwrite(ciphertext, 1, ciphertext_len, file);\n\n  free(ciphertext);\n  return 0;\n}\n\n```\nNote that for the 'GOOD' example to work we need to link against an encryption library (in this case libsodium), initialize it with a call to `sodium_init`, and create the key and nonce with `crypto_secretbox_keygen` and `randombytes_buf` respectively. We also need to store those details securely so they can be used for decryption.\n\n\n## References\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-260](https://cwe.mitre.org/data/definitions/260.html).\n* Common Weakness Enumeration: [CWE-313](https://cwe.mitre.org/data/definitions/313.html).\n","markdown":"# Cleartext storage of sensitive information in file\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored to a file or transmitted over the network. It may be wise to encrypt information before it is put into a buffer that may be readable in memory.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\n\n## Example\nThe following example shows two ways of storing user credentials in a file. In the 'BAD' case, the credentials are simply stored in cleartext. In the 'GOOD' case, the credentials are encrypted before storing them.\n\n\n```c\n#include <sodium.h>\n#include <stdio.h>\n#include <string.h>\n\nvoid writeCredentialsBad(FILE *file, const char *cleartextCredentials) {\n  // BAD: write password to disk in cleartext\n  fputs(cleartextCredentials, file);\n}\n\nint writeCredentialsGood(FILE *file, const char *cleartextCredentials, const unsigned char *key, const unsigned char *nonce) {\n  size_t credentialsLen = strlen(cleartextCredentials);\n  size_t ciphertext_len = crypto_secretbox_MACBYTES + credentialsLen;\n  unsigned char *ciphertext = malloc(ciphertext_len);\n  if (!ciphertext) {\n    logError();\n    return -1;\n  }\n\n  // encrypt the password first\n  if (crypto_secretbox_easy(ciphertext, (const unsigned char *)cleartextCredentials, credentialsLen, nonce, key) != 0) {\n    free(ciphertext);\n    logError();\n    return -1;\n  }\n\n  // GOOD: write encrypted password to disk\n  fwrite(ciphertext, 1, ciphertext_len, file);\n\n  free(ciphertext);\n  return 0;\n}\n\n```\nNote that for the 'GOOD' example to work we need to link against an encryption library (in this case libsodium), initialize it with a call to `sodium_init`, and create the key and nonce with `crypto_secretbox_keygen` and `randombytes_buf` respectively. We also need to store those details securely so they can be used for decryption.\n\n\n## References\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-260](https://cwe.mitre.org/data/definitions/260.html).\n* Common Weakness Enumeration: [CWE-313](https://cwe.mitre.org/data/definitions/313.html).\n"},"properties":{"tags":["security","external/cwe/cwe-260","external/cwe/cwe-313"],"description":"Storing sensitive information in cleartext can expose it\n              to an attacker.","id":"cpp/cleartext-storage-file","kind":"path-problem","name":"Cleartext storage of sensitive information in file","precision":"high","problem.severity":"warning","security-severity":"7.5"}},{"id":"cpp/cleartext-transmission","name":"cpp/cleartext-transmission","shortDescription":{"text":"Cleartext transmission of sensitive information"},"fullDescription":{"text":"Transmitting sensitive information across a network in cleartext can expose it to an attacker."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Cleartext transmission of sensitive information\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored to a file or transmitted over the network. It may be wise to encrypt information before it is put into a buffer that may be readable in memory.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\n\n## Example\nThe following example shows two ways of storing user credentials in a file. In the 'BAD' case, the credentials are simply stored in cleartext. In the 'GOOD' case, the credentials are encrypted before storing them.\n\n\n```c\n#include <sodium.h>\n#include <stdio.h>\n#include <string.h>\n\nvoid writeCredentialsBad(FILE *file, const char *cleartextCredentials) {\n  // BAD: write password to disk in cleartext\n  fputs(cleartextCredentials, file);\n}\n\nint writeCredentialsGood(FILE *file, const char *cleartextCredentials, const unsigned char *key, const unsigned char *nonce) {\n  size_t credentialsLen = strlen(cleartextCredentials);\n  size_t ciphertext_len = crypto_secretbox_MACBYTES + credentialsLen;\n  unsigned char *ciphertext = malloc(ciphertext_len);\n  if (!ciphertext) {\n    logError();\n    return -1;\n  }\n\n  // encrypt the password first\n  if (crypto_secretbox_easy(ciphertext, (const unsigned char *)cleartextCredentials, credentialsLen, nonce, key) != 0) {\n    free(ciphertext);\n    logError();\n    return -1;\n  }\n\n  // GOOD: write encrypted password to disk\n  fwrite(ciphertext, 1, ciphertext_len, file);\n\n  free(ciphertext);\n  return 0;\n}\n\n```\nNote that for the 'GOOD' example to work we need to link against an encryption library (in this case libsodium), initialize it with a call to `sodium_init`, and create the key and nonce with `crypto_secretbox_keygen` and `randombytes_buf` respectively. We also need to store those details securely so they can be used for decryption.\n\n\n## References\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n","markdown":"# Cleartext transmission of sensitive information\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored to a file or transmitted over the network. It may be wise to encrypt information before it is put into a buffer that may be readable in memory.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\n\n## Example\nThe following example shows two ways of storing user credentials in a file. In the 'BAD' case, the credentials are simply stored in cleartext. In the 'GOOD' case, the credentials are encrypted before storing them.\n\n\n```c\n#include <sodium.h>\n#include <stdio.h>\n#include <string.h>\n\nvoid writeCredentialsBad(FILE *file, const char *cleartextCredentials) {\n  // BAD: write password to disk in cleartext\n  fputs(cleartextCredentials, file);\n}\n\nint writeCredentialsGood(FILE *file, const char *cleartextCredentials, const unsigned char *key, const unsigned char *nonce) {\n  size_t credentialsLen = strlen(cleartextCredentials);\n  size_t ciphertext_len = crypto_secretbox_MACBYTES + credentialsLen;\n  unsigned char *ciphertext = malloc(ciphertext_len);\n  if (!ciphertext) {\n    logError();\n    return -1;\n  }\n\n  // encrypt the password first\n  if (crypto_secretbox_easy(ciphertext, (const unsigned char *)cleartextCredentials, credentialsLen, nonce, key) != 0) {\n    free(ciphertext);\n    logError();\n    return -1;\n  }\n\n  // GOOD: write encrypted password to disk\n  fwrite(ciphertext, 1, ciphertext_len, file);\n\n  free(ciphertext);\n  return 0;\n}\n\n```\nNote that for the 'GOOD' example to work we need to link against an encryption library (in this case libsodium), initialize it with a call to `sodium_init`, and create the key and nonce with `crypto_secretbox_keygen` and `randombytes_buf` respectively. We also need to store those details securely so they can be used for decryption.\n\n\n## References\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n"},"properties":{"tags":["security","external/cwe/cwe-319","external/cwe/cwe-359"],"description":"Transmitting sensitive information across a network in\n              cleartext can expose it to an attacker.","id":"cpp/cleartext-transmission","kind":"path-problem","name":"Cleartext transmission of sensitive information","precision":"high","problem.severity":"warning","security-severity":"7.5"}},{"id":"cpp/memset-may-be-deleted","name":"cpp/memset-may-be-deleted","shortDescription":{"text":"Call to `memset` may be deleted"},"fullDescription":{"text":"Using the `memset` function to clear private data in a variable that has no subsequent use can make information-leak vulnerabilities easier to exploit because the compiler can remove the call."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Call to `memset` may be deleted\nCalling `memset` or `bzero` on a buffer to clear its contents may get optimized away by the compiler if the buffer is not subsequently used. This is not desirable behavior if the buffer contains sensitive data that could somehow be retrieved by an attacker.\n\n\n## Recommendation\nUse `memset_s` (from C11) instead of `memset`, as `memset_s` will not get optimized away. Alternatively use platform-supplied functions such as `SecureZeroMemory` or `bzero_explicit` that make the same guarantee. Passing the `-fno-builtin-memset` option to the GCC/Clang compiler usually also prevents the optimization. Finally, you can use the public-domain `secure_memzero` function (see references below). This function, however, is not guaranteed to work on all platforms and compilers.\n\n\n## Example\nThe following program fragment uses `memset` to erase sensitive information after it is no longer needed:\n\n\n```c\nchar password[MAX_PASSWORD_LENGTH];\n// read and verify password\nmemset(password, 0, MAX_PASSWORD_LENGTH);\n\n```\nBecause of dead store elimination, the call to `memset` may be removed by the compiler (since the buffer is not subsequently used), resulting in potentially sensitive data remaining in memory.\n\nThe best solution to this problem is to use the `memset_s` function instead of `memset`:\n\n\n```c\nchar password[MAX_PASSWORD_LENGTH];\n// read and verify password\nmemset_s(password, MAX_PASSWORD_LENGTH, 0, MAX_PASSWORD_LENGTH);\n\n```\n\n## References\n* CERT C Coding Standard: [MSC06-C. Beware of compiler optimizations](https://wiki.sei.cmu.edu/confluence/display/c/MSC06-C.+Beware+of+compiler+optimizations).\n* USENIX: The Advanced Computing Systems Association: [Dead Store Elimination (Still) Considered Harmfuls](https://www.usenix.org/system/files/conference/usenixsecurity17/sec17-yang.pdf)\n* Common Weakness Enumeration: [CWE-14](https://cwe.mitre.org/data/definitions/14.html).\n","markdown":"# Call to `memset` may be deleted\nCalling `memset` or `bzero` on a buffer to clear its contents may get optimized away by the compiler if the buffer is not subsequently used. This is not desirable behavior if the buffer contains sensitive data that could somehow be retrieved by an attacker.\n\n\n## Recommendation\nUse `memset_s` (from C11) instead of `memset`, as `memset_s` will not get optimized away. Alternatively use platform-supplied functions such as `SecureZeroMemory` or `bzero_explicit` that make the same guarantee. Passing the `-fno-builtin-memset` option to the GCC/Clang compiler usually also prevents the optimization. Finally, you can use the public-domain `secure_memzero` function (see references below). This function, however, is not guaranteed to work on all platforms and compilers.\n\n\n## Example\nThe following program fragment uses `memset` to erase sensitive information after it is no longer needed:\n\n\n```c\nchar password[MAX_PASSWORD_LENGTH];\n// read and verify password\nmemset(password, 0, MAX_PASSWORD_LENGTH);\n\n```\nBecause of dead store elimination, the call to `memset` may be removed by the compiler (since the buffer is not subsequently used), resulting in potentially sensitive data remaining in memory.\n\nThe best solution to this problem is to use the `memset_s` function instead of `memset`:\n\n\n```c\nchar password[MAX_PASSWORD_LENGTH];\n// read and verify password\nmemset_s(password, MAX_PASSWORD_LENGTH, 0, MAX_PASSWORD_LENGTH);\n\n```\n\n## References\n* CERT C Coding Standard: [MSC06-C. Beware of compiler optimizations](https://wiki.sei.cmu.edu/confluence/display/c/MSC06-C.+Beware+of+compiler+optimizations).\n* USENIX: The Advanced Computing Systems Association: [Dead Store Elimination (Still) Considered Harmfuls](https://www.usenix.org/system/files/conference/usenixsecurity17/sec17-yang.pdf)\n* Common Weakness Enumeration: [CWE-14](https://cwe.mitre.org/data/definitions/14.html).\n"},"properties":{"tags":["security","external/cwe/cwe-014"],"description":"Using the `memset` function to clear private data in a variable that has no subsequent use\n              can make information-leak vulnerabilities easier to exploit because the compiler can remove the call.","id":"cpp/memset-may-be-deleted","kind":"problem","name":"Call to `memset` may be deleted","precision":"high","problem.severity":"warning","security-severity":"7.8"}},{"id":"cpp/incorrect-string-type-conversion","name":"cpp/incorrect-string-type-conversion","shortDescription":{"text":"Cast from char* to wchar_t*"},"fullDescription":{"text":"Casting a byte string to a wide-character string is likely to yield a string that is incorrectly terminated or aligned. This can lead to undefined behavior, including buffer overruns."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Cast from char* to wchar_t*\nThis rule indicates a potentially incorrect cast from an byte string (`char *`) to a wide-character string (`wchar_t *`).\n\nThis cast might yield strings that are not correctly terminated; including potential buffer overruns when using such strings with some dangerous APIs.\n\n\n## Recommendation\nDo not explicitly cast byte strings to wide-character strings.\n\nFor string literals, prepend the literal string with the letter \"L\" to indicate that the string is a wide-character string (`wchar_t *`).\n\nFor converting a byte literal to a wide-character string literal, you would need to use the appropriate conversion function for the platform you are using. Please see the references section for options according to your platform.\n\n\n## Example\nIn the following example, an byte string literal (`\"a\"`) is cast to a wide-character string.\n\n\n```cpp\nwchar_t* pSrc;\n\npSrc = (wchar_t*)\"a\"; // casting a byte-string literal \"a\" to a wide-character string\n```\nTo fix this issue, prepend the literal with the letter \"L\" (`L\"a\"`) to define it as a wide-character string.\n\n\n## References\n* General resources: [std::mbstowcs](https://en.cppreference.com/w/cpp/string/multibyte/mbstowcs)\n* Microsoft specific resources: [Security Considerations: International Features](https://docs.microsoft.com/en-us/windows/desktop/Intl/security-considerations--international-features)\n* Common Weakness Enumeration: [CWE-704](https://cwe.mitre.org/data/definitions/704.html).\n","markdown":"# Cast from char* to wchar_t*\nThis rule indicates a potentially incorrect cast from an byte string (`char *`) to a wide-character string (`wchar_t *`).\n\nThis cast might yield strings that are not correctly terminated; including potential buffer overruns when using such strings with some dangerous APIs.\n\n\n## Recommendation\nDo not explicitly cast byte strings to wide-character strings.\n\nFor string literals, prepend the literal string with the letter \"L\" to indicate that the string is a wide-character string (`wchar_t *`).\n\nFor converting a byte literal to a wide-character string literal, you would need to use the appropriate conversion function for the platform you are using. Please see the references section for options according to your platform.\n\n\n## Example\nIn the following example, an byte string literal (`\"a\"`) is cast to a wide-character string.\n\n\n```cpp\nwchar_t* pSrc;\n\npSrc = (wchar_t*)\"a\"; // casting a byte-string literal \"a\" to a wide-character string\n```\nTo fix this issue, prepend the literal with the letter \"L\" (`L\"a\"`) to define it as a wide-character string.\n\n\n## References\n* General resources: [std::mbstowcs](https://en.cppreference.com/w/cpp/string/multibyte/mbstowcs)\n* Microsoft specific resources: [Security Considerations: International Features](https://docs.microsoft.com/en-us/windows/desktop/Intl/security-considerations--international-features)\n* Common Weakness Enumeration: [CWE-704](https://cwe.mitre.org/data/definitions/704.html).\n"},"properties":{"tags":["security","external/cwe/cwe-704"],"description":"Casting a byte string to a wide-character string is likely\n              to yield a string that is incorrectly terminated or aligned.\n              This can lead to undefined behavior, including buffer overruns.","id":"cpp/incorrect-string-type-conversion","kind":"problem","name":"Cast from char* to wchar_t*","precision":"high","problem.severity":"error","security-severity":"8.8"}},{"id":"cpp/command-line-injection","name":"cpp/command-line-injection","shortDescription":{"text":"Uncontrolled data used in OS command"},"fullDescription":{"text":"Using user-supplied data in an OS command, without neutralizing special elements, can make code vulnerable to command injection."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Uncontrolled data used in OS command\nThe code passes user input as part of a call to `system` or `popen` without escaping special elements. It generates a command line using `sprintf`, with the user-supplied data directly passed as a formatting argument. This leaves the code vulnerable to attack by command injection.\n\n\n## Recommendation\nUse a library routine to escape characters in the user-supplied string before passing it to a command shell.\n\n\n## Example\nThe following example runs an external command in two ways. The first way uses `sprintf` to build a command directly out of a user-supplied argument. As such, it is vulnerable to command injection. The second way quotes the user-provided value before embedding it in the command; assuming the `encodeShellString` utility is correct, this code should be safe against command injection.\n\n\n```c\nint main(int argc, char** argv) {\n  char *userName = argv[2];\n  \n  {\n    // BAD: a string from the user is injected directly into\n    // a command line.\n    char command1[1000] = {0};\n    sprintf(command1, \"userinfo -v \\\"%s\\\"\", userName);\n    system(command1);\n  }\n\n  {\n    // GOOD: the user string is encoded by a library routine.\n    char userNameQuoted[1000] = {0};\n    encodeShellString(userNameQuoted, 1000, userName); \n    char command2[1000] = {0};\n    sprintf(command2, \"userinfo -v %s\", userNameQuoted);\n    system(command2);\n  }\n}\n\n```\n\n## References\n* CERT C Coding Standard: [STR02-C. Sanitize data passed to complex subsystems](https://www.securecoding.cert.org/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems).\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n","markdown":"# Uncontrolled data used in OS command\nThe code passes user input as part of a call to `system` or `popen` without escaping special elements. It generates a command line using `sprintf`, with the user-supplied data directly passed as a formatting argument. This leaves the code vulnerable to attack by command injection.\n\n\n## Recommendation\nUse a library routine to escape characters in the user-supplied string before passing it to a command shell.\n\n\n## Example\nThe following example runs an external command in two ways. The first way uses `sprintf` to build a command directly out of a user-supplied argument. As such, it is vulnerable to command injection. The second way quotes the user-provided value before embedding it in the command; assuming the `encodeShellString` utility is correct, this code should be safe against command injection.\n\n\n```c\nint main(int argc, char** argv) {\n  char *userName = argv[2];\n  \n  {\n    // BAD: a string from the user is injected directly into\n    // a command line.\n    char command1[1000] = {0};\n    sprintf(command1, \"userinfo -v \\\"%s\\\"\", userName);\n    system(command1);\n  }\n\n  {\n    // GOOD: the user string is encoded by a library routine.\n    char userNameQuoted[1000] = {0};\n    encodeShellString(userNameQuoted, 1000, userName); \n    char command2[1000] = {0};\n    sprintf(command2, \"userinfo -v %s\", userNameQuoted);\n    system(command2);\n  }\n}\n\n```\n\n## References\n* CERT C Coding Standard: [STR02-C. Sanitize data passed to complex subsystems](https://www.securecoding.cert.org/confluence/display/c/STR02-C.+Sanitize+data+passed+to+complex+subsystems).\n* OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).\n"},"properties":{"tags":["security","external/cwe/cwe-078","external/cwe/cwe-088"],"description":"Using user-supplied data in an OS command, without\n              neutralizing special elements, can make code vulnerable\n              to command injection.","id":"cpp/command-line-injection","kind":"path-problem","name":"Uncontrolled data used in OS command","precision":"high","problem.severity":"error","security-severity":"9.8"}},{"id":"cpp/toctou-race-condition","name":"cpp/toctou-race-condition","shortDescription":{"text":"Time-of-check time-of-use filesystem race condition"},"fullDescription":{"text":"Separately checking the state of a file before operating on it may allow an attacker to modify the file between the two operations."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Time-of-check time-of-use filesystem race condition\nOften it is necessary to check the state of a file before using it. These checks usually take a file name to be checked, and if the check returns positively, then the file is opened or otherwise operated upon.\n\nHowever, in the time between the check and the operation, the underlying file referenced by the file name could be changed by an attacker, causing unexpected behavior.\n\n\n## Recommendation\nWherever possible, use functions that operate on file descriptors rather than file names (for example, `fchmod` rather than `chmod`).\n\nFor access checks, you can temporarily change the UID and GID to that of the user whose permissions are being checked, and then perform the operation. This has the effect of \"atomically\" combining a permissions check with the operation.\n\nIf file-system locking tools are available on your platform, then locking the file before the check can prevent an unexpected update. However, note that on some platforms (for example, Unix) file-system locks are typically *advisory*, and so can be ignored by an attacker.\n\n\n## Example\nThe following example shows a case where a file is opened and then, if the opening was successful, its permissions are changed with `chmod`. However, an attacker might change the target of the file name between the initial opening and the permissions change, potentially changing the permissions of a different file.\n\n\n```c\nchar *file_name;\nFILE *f_ptr;\n\n/* Initialize file_name */\n\nf_ptr = fopen(file_name, \"w\");\nif (f_ptr == NULL)  {\n  /* Handle error */\n}\n\n/* ... */\n\nif (chmod(file_name, S_IRUSR) == -1) {\n  /* Handle error */\n}\n\nfclose(f_ptr);\n\n```\nThis can be avoided by using `fchmod` with the file descriptor that was received from opening the file. This ensures that the permissions change is applied to the very same file that was opened.\n\n\n```c\nchar *file_name;\nint fd;\n\n/* Initialize file_name */\n\nfd = open(\n  file_name,\n  O_WRONLY | O_CREAT | O_EXCL,\n  S_IRWXU\n);\nif (fd == -1) {\n  /* Handle error */\n}\n\n/* ... */\n\nif (fchmod(fd, S_IRUSR) == -1) {\n  /* Handle error */\n}\n\nclose(fd);\n\n```\n\n## References\n* The CERT Oracle Secure Coding Standard for C: [ FIO01-C. Be careful using functions that use file names for identification ](https://www.securecoding.cert.org/confluence/display/c/FIO01-C.+Be+careful+using+functions+that+use+file+names+for+identification).\n* Common Weakness Enumeration: [CWE-367](https://cwe.mitre.org/data/definitions/367.html).\n","markdown":"# Time-of-check time-of-use filesystem race condition\nOften it is necessary to check the state of a file before using it. These checks usually take a file name to be checked, and if the check returns positively, then the file is opened or otherwise operated upon.\n\nHowever, in the time between the check and the operation, the underlying file referenced by the file name could be changed by an attacker, causing unexpected behavior.\n\n\n## Recommendation\nWherever possible, use functions that operate on file descriptors rather than file names (for example, `fchmod` rather than `chmod`).\n\nFor access checks, you can temporarily change the UID and GID to that of the user whose permissions are being checked, and then perform the operation. This has the effect of \"atomically\" combining a permissions check with the operation.\n\nIf file-system locking tools are available on your platform, then locking the file before the check can prevent an unexpected update. However, note that on some platforms (for example, Unix) file-system locks are typically *advisory*, and so can be ignored by an attacker.\n\n\n## Example\nThe following example shows a case where a file is opened and then, if the opening was successful, its permissions are changed with `chmod`. However, an attacker might change the target of the file name between the initial opening and the permissions change, potentially changing the permissions of a different file.\n\n\n```c\nchar *file_name;\nFILE *f_ptr;\n\n/* Initialize file_name */\n\nf_ptr = fopen(file_name, \"w\");\nif (f_ptr == NULL)  {\n  /* Handle error */\n}\n\n/* ... */\n\nif (chmod(file_name, S_IRUSR) == -1) {\n  /* Handle error */\n}\n\nfclose(f_ptr);\n\n```\nThis can be avoided by using `fchmod` with the file descriptor that was received from opening the file. This ensures that the permissions change is applied to the very same file that was opened.\n\n\n```c\nchar *file_name;\nint fd;\n\n/* Initialize file_name */\n\nfd = open(\n  file_name,\n  O_WRONLY | O_CREAT | O_EXCL,\n  S_IRWXU\n);\nif (fd == -1) {\n  /* Handle error */\n}\n\n/* ... */\n\nif (fchmod(fd, S_IRUSR) == -1) {\n  /* Handle error */\n}\n\nclose(fd);\n\n```\n\n## References\n* The CERT Oracle Secure Coding Standard for C: [ FIO01-C. Be careful using functions that use file names for identification ](https://www.securecoding.cert.org/confluence/display/c/FIO01-C.+Be+careful+using+functions+that+use+file+names+for+identification).\n* Common Weakness Enumeration: [CWE-367](https://cwe.mitre.org/data/definitions/367.html).\n"},"properties":{"tags":["security","external/cwe/cwe-367"],"description":"Separately checking the state of a file before operating\n              on it may allow an attacker to modify the file between\n              the two operations.","id":"cpp/toctou-race-condition","kind":"problem","name":"Time-of-check time-of-use filesystem race condition","precision":"high","problem.severity":"warning","security-severity":"7.7"}},{"id":"cpp/sql-injection","name":"cpp/sql-injection","shortDescription":{"text":"Uncontrolled data in SQL query"},"fullDescription":{"text":"Including user-supplied data in a SQL query without neutralizing special elements can make code vulnerable to SQL Injection."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Uncontrolled data in SQL query\nThe code passes user input as part of a SQL query without escaping special elements. It generates a SQL query using `sprintf`, with the user-supplied data directly passed as an argument to `sprintf`. This leaves the code vulnerable to attack by SQL Injection.\n\n\n## Recommendation\nUse a library routine to escape characters in the user-supplied string before converting it to SQL.\n\n\n## Example\n\n```c\nint main(int argc, char** argv) {\n  char *userName = argv[2];\n  \n  // BAD\n  char query1[1000] = {0};\n  sprintf(query1, \"SELECT UID FROM USERS where name = \\\"%s\\\"\", userName);\n  runSql(query1);\n  \n  // GOOD\n  char userNameSql[1000] = {0};\n  encodeSqlString(userNameSql, 1000, userName); \n  char query2[1000] = {0};\n  sprintf(query2, \"SELECT UID FROM USERS where name = \\\"%s\\\"\", userNameSql);\n  runSql(query2);\n}\n\n```\n\n## References\n* MSDN Library: [SQL Injection](https://docs.microsoft.com/en-us/sql/relational-databases/security/sql-injection).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n","markdown":"# Uncontrolled data in SQL query\nThe code passes user input as part of a SQL query without escaping special elements. It generates a SQL query using `sprintf`, with the user-supplied data directly passed as an argument to `sprintf`. This leaves the code vulnerable to attack by SQL Injection.\n\n\n## Recommendation\nUse a library routine to escape characters in the user-supplied string before converting it to SQL.\n\n\n## Example\n\n```c\nint main(int argc, char** argv) {\n  char *userName = argv[2];\n  \n  // BAD\n  char query1[1000] = {0};\n  sprintf(query1, \"SELECT UID FROM USERS where name = \\\"%s\\\"\", userName);\n  runSql(query1);\n  \n  // GOOD\n  char userNameSql[1000] = {0};\n  encodeSqlString(userNameSql, 1000, userName); \n  char query2[1000] = {0};\n  sprintf(query2, \"SELECT UID FROM USERS where name = \\\"%s\\\"\", userNameSql);\n  runSql(query2);\n}\n\n```\n\n## References\n* MSDN Library: [SQL Injection](https://docs.microsoft.com/en-us/sql/relational-databases/security/sql-injection).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n"},"properties":{"tags":["security","external/cwe/cwe-089"],"description":"Including user-supplied data in a SQL query without\n              neutralizing special elements can make code vulnerable\n              to SQL Injection.","id":"cpp/sql-injection","kind":"path-problem","name":"Uncontrolled data in SQL query","precision":"high","problem.severity":"error","security-severity":"8.8"}},{"id":"cpp/use-of-unique-pointer-after-lifetime-ends","name":"cpp/use-of-unique-pointer-after-lifetime-ends","shortDescription":{"text":"Use of unique pointer after lifetime ends"},"fullDescription":{"text":"Referencing the contents of a unique pointer after the underlying object has expired may lead to unexpected behavior."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Use of unique pointer after lifetime ends\nCalling `get` on a `std::unique_ptr` object returns a pointer to the underlying allocations. When the `std::unique_ptr` object is destroyed, the pointer returned by `get` is no longer valid. If the pointer is used after the `std::unique_ptr` object is destroyed, then the behavior is undefined.\n\n\n## Recommendation\nEnsure that the pointer returned by `get` does not outlive the underlying `std::unique_ptr` object.\n\n\n## Example\nThe following example gets a `std::unique_ptr` object, and then converts the resulting unique pointer to a pointer using `get` so that it can be passed to the `work` function. However, the `std::unique_ptr` object is destroyed as soon as the call to `get` returns. This means that `work` is given a pointer to invalid memory.\n\n\n```cpp\n#include <memory>\nstd::unique_ptr<T> getUniquePointer();\nvoid work(const T*);\n\n// BAD: the unique pointer is deallocated when `get` returns. So `work`\n// is given a pointer to invalid memory.\nvoid work_with_unique_ptr_bad() {\n  const T* combined_string = getUniquePointer().get();\n  work(combined_string);\n}\n```\nThe following example fixes the above code by ensuring that the pointer returned by the call to `get` does not outlive the underlying `std::unique_ptr` objects. This ensures that the pointer passed to `work` points to valid memory.\n\n\n```cpp\n#include <memory>\nstd::unique_ptr<T> getUniquePointer();\nvoid work(const T*);\n\n// GOOD: the unique pointer outlives the call to `work`. So the pointer\n// obtainted from `get` is valid.\nvoid work_with_unique_ptr_good() {\n  auto combined_string = getUniquePointer();\n  work(combined_string.get());\n}\n```\n\n## References\n* [MEM50-CPP. Do not access freed memory](https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM50-CPP.+Do+not+access+freed+memory).\n* Common Weakness Enumeration: [CWE-416](https://cwe.mitre.org/data/definitions/416.html).\n* Common Weakness Enumeration: [CWE-664](https://cwe.mitre.org/data/definitions/664.html).\n","markdown":"# Use of unique pointer after lifetime ends\nCalling `get` on a `std::unique_ptr` object returns a pointer to the underlying allocations. When the `std::unique_ptr` object is destroyed, the pointer returned by `get` is no longer valid. If the pointer is used after the `std::unique_ptr` object is destroyed, then the behavior is undefined.\n\n\n## Recommendation\nEnsure that the pointer returned by `get` does not outlive the underlying `std::unique_ptr` object.\n\n\n## Example\nThe following example gets a `std::unique_ptr` object, and then converts the resulting unique pointer to a pointer using `get` so that it can be passed to the `work` function. However, the `std::unique_ptr` object is destroyed as soon as the call to `get` returns. This means that `work` is given a pointer to invalid memory.\n\n\n```cpp\n#include <memory>\nstd::unique_ptr<T> getUniquePointer();\nvoid work(const T*);\n\n// BAD: the unique pointer is deallocated when `get` returns. So `work`\n// is given a pointer to invalid memory.\nvoid work_with_unique_ptr_bad() {\n  const T* combined_string = getUniquePointer().get();\n  work(combined_string);\n}\n```\nThe following example fixes the above code by ensuring that the pointer returned by the call to `get` does not outlive the underlying `std::unique_ptr` objects. This ensures that the pointer passed to `work` points to valid memory.\n\n\n```cpp\n#include <memory>\nstd::unique_ptr<T> getUniquePointer();\nvoid work(const T*);\n\n// GOOD: the unique pointer outlives the call to `work`. So the pointer\n// obtainted from `get` is valid.\nvoid work_with_unique_ptr_good() {\n  auto combined_string = getUniquePointer();\n  work(combined_string.get());\n}\n```\n\n## References\n* [MEM50-CPP. Do not access freed memory](https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM50-CPP.+Do+not+access+freed+memory).\n* Common Weakness Enumeration: [CWE-416](https://cwe.mitre.org/data/definitions/416.html).\n* Common Weakness Enumeration: [CWE-664](https://cwe.mitre.org/data/definitions/664.html).\n"},"properties":{"tags":["reliability","security","external/cwe/cwe-416","external/cwe/cwe-664"],"description":"Referencing the contents of a unique pointer after the underlying object has expired may lead to unexpected behavior.","id":"cpp/use-of-unique-pointer-after-lifetime-ends","kind":"problem","name":"Use of unique pointer after lifetime ends","precision":"high","problem.severity":"warning","security-severity":"8.8"}},{"id":"cpp/iterator-to-expired-container","name":"cpp/iterator-to-expired-container","shortDescription":{"text":"Iterator to expired container"},"fullDescription":{"text":"Using an iterator owned by a container whose lifetime has expired may lead to unexpected behavior."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Iterator to expired container\nUsing an iterator owned by a container after the lifetime of the container has expired can lead to undefined behavior. This is because the iterator may be invalidated when the container is destroyed, and dereferencing an invalidated iterator is undefined behavior. These problems can be hard to spot due to C++'s complex rules for temporary object lifetimes and their extensions.\n\n\n## Recommendation\nNever create an iterator to a temporary container when the iterator is expected to be used after the container's lifetime has expired.\n\n\n## Example\n\n\nThe rules for lifetime extension ensures that the code in `lifetime_of_temp_extended` is well-defined. This is because the lifetime of the temporary container returned by `get_vector` is extended to the end of the loop. However, prior to C++23, the lifetime extension rules do not ensure that the container returned by `get_vector` is extended in `lifetime_of_temp_not_extended`. This is because the temporary container is not bound to a rvalue reference.\n\n\n```cpp\n#include <vector>\n\nstd::vector<int> get_vector();\n\nvoid use(int);\n\nvoid lifetime_of_temp_extended() {\n  for(auto x : get_vector()) {\n    use(x); // GOOD: The lifetime of the vector returned by `get_vector()` is extended until the end of the loop.\n  }\n}\n\n// Writes the the values of `v` to an external log and returns it unchanged.\nconst std::vector<int>& log_and_return_argument(const std::vector<int>& v);\n\nvoid lifetime_of_temp_not_extended() {\n  for(auto x : log_and_return_argument(get_vector())) {\n    use(x); // BAD: The lifetime of the vector returned by `get_vector()` is not extended, and the behavior is undefined.\n  }\n}\n\n```\nTo fix `lifetime_of_temp_not_extended`, consider rewriting the code so that the lifetime of the temporary object is extended. In `fixed_lifetime_of_temp_not_extended`, the lifetime of the temporary object has been extended by storing it in an rvalue reference.\n\n\n```cpp\nvoid fixed_lifetime_of_temp_not_extended() {\n  auto&& v = get_vector();\n  for(auto x : log_and_return_argument(v)) {\n    use(x); // GOOD: The lifetime of the container returned by `get_vector()` has been extended to the lifetime of `v`.\n  }\n}\n\n```\n\n## References\n* CERT C Coding Standard: [MEM30-C. Do not access freed memory](https://wiki.sei.cmu.edu/confluence/display/c/MEM30-C.+Do+not+access+freed+memory).\n* OWASP: [Using freed memory](https://owasp.org/www-community/vulnerabilities/Using_freed_memory).\n* [Lifetime safety: Preventing common dangling](https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Lifetime.pdf)\n* [Containers library](https://en.cppreference.com/w/cpp/container)\n* [Range-based for loop (since C++11)](https://en.cppreference.com/w/cpp/language/range-for)\n* Common Weakness Enumeration: [CWE-416](https://cwe.mitre.org/data/definitions/416.html).\n* Common Weakness Enumeration: [CWE-664](https://cwe.mitre.org/data/definitions/664.html).\n","markdown":"# Iterator to expired container\nUsing an iterator owned by a container after the lifetime of the container has expired can lead to undefined behavior. This is because the iterator may be invalidated when the container is destroyed, and dereferencing an invalidated iterator is undefined behavior. These problems can be hard to spot due to C++'s complex rules for temporary object lifetimes and their extensions.\n\n\n## Recommendation\nNever create an iterator to a temporary container when the iterator is expected to be used after the container's lifetime has expired.\n\n\n## Example\n\n\nThe rules for lifetime extension ensures that the code in `lifetime_of_temp_extended` is well-defined. This is because the lifetime of the temporary container returned by `get_vector` is extended to the end of the loop. However, prior to C++23, the lifetime extension rules do not ensure that the container returned by `get_vector` is extended in `lifetime_of_temp_not_extended`. This is because the temporary container is not bound to a rvalue reference.\n\n\n```cpp\n#include <vector>\n\nstd::vector<int> get_vector();\n\nvoid use(int);\n\nvoid lifetime_of_temp_extended() {\n  for(auto x : get_vector()) {\n    use(x); // GOOD: The lifetime of the vector returned by `get_vector()` is extended until the end of the loop.\n  }\n}\n\n// Writes the the values of `v` to an external log and returns it unchanged.\nconst std::vector<int>& log_and_return_argument(const std::vector<int>& v);\n\nvoid lifetime_of_temp_not_extended() {\n  for(auto x : log_and_return_argument(get_vector())) {\n    use(x); // BAD: The lifetime of the vector returned by `get_vector()` is not extended, and the behavior is undefined.\n  }\n}\n\n```\nTo fix `lifetime_of_temp_not_extended`, consider rewriting the code so that the lifetime of the temporary object is extended. In `fixed_lifetime_of_temp_not_extended`, the lifetime of the temporary object has been extended by storing it in an rvalue reference.\n\n\n```cpp\nvoid fixed_lifetime_of_temp_not_extended() {\n  auto&& v = get_vector();\n  for(auto x : log_and_return_argument(v)) {\n    use(x); // GOOD: The lifetime of the container returned by `get_vector()` has been extended to the lifetime of `v`.\n  }\n}\n\n```\n\n## References\n* CERT C Coding Standard: [MEM30-C. Do not access freed memory](https://wiki.sei.cmu.edu/confluence/display/c/MEM30-C.+Do+not+access+freed+memory).\n* OWASP: [Using freed memory](https://owasp.org/www-community/vulnerabilities/Using_freed_memory).\n* [Lifetime safety: Preventing common dangling](https://github.com/isocpp/CppCoreGuidelines/blob/master/docs/Lifetime.pdf)\n* [Containers library](https://en.cppreference.com/w/cpp/container)\n* [Range-based for loop (since C++11)](https://en.cppreference.com/w/cpp/language/range-for)\n* Common Weakness Enumeration: [CWE-416](https://cwe.mitre.org/data/definitions/416.html).\n* Common Weakness Enumeration: [CWE-664](https://cwe.mitre.org/data/definitions/664.html).\n"},"properties":{"tags":["reliability","security","external/cwe/cwe-416","external/cwe/cwe-664"],"description":"Using an iterator owned by a container whose lifetime has expired may lead to unexpected behavior.","id":"cpp/iterator-to-expired-container","kind":"problem","name":"Iterator to expired container","precision":"high","problem.severity":"warning","security-severity":"8.8"}},{"id":"cpp/use-of-string-after-lifetime-ends","name":"cpp/use-of-string-after-lifetime-ends","shortDescription":{"text":"Use of string after lifetime ends"},"fullDescription":{"text":"If the value of a call to 'c_str' outlives the underlying object it may lead to unexpected behavior."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Use of string after lifetime ends\nCalling `c_str` on a `std::string` object returns a pointer to the underlying character array. When the `std::string` object is destroyed, the pointer returned by `c_str` is no longer valid. If the pointer is used after the `std::string` object is destroyed, then the behavior is undefined.\n\nTypically, this problem occurs when a `std::string` is returned by a function call (or overloaded operator) by value, and the result is not immediately stored in a variable by value or reference in a way that extends the lifetime of the temporary object. The resulting temporary `std::string` object is destroyed at the end of the containing expression statement, along with any memory returned by a call to `c_str`.\n\n\n## Recommendation\nEnsure that the pointer returned by `c_str` does not outlive the underlying `std::string` object.\n\n\n## Example\nThe following example concatenates two `std::string` objects, and then converts the resulting string to a C string using `c_str` so that it can be passed to the `work` function. However, the underlying `std::string` object that represents the concatenated string is destroyed as soon as the call to `c_str` returns. This means that `work` is given a pointer to invalid memory.\n\n\n```cpp\n#include <string>\nvoid work(const char*);\n\n// BAD: the concatenated string is deallocated when `c_str` returns. So `work`\n// is given a pointer to invalid memory.\nvoid work_with_combined_string_bad(std::string s1, std::string s2) {\n  const char* combined_string = (s1 + s2).c_str();\n  work(combined_string);\n}\n```\nThe following example fixes the above code by ensuring that the pointer returned by the call to `c_str` does not outlive the underlying `std::string` objects. This ensures that the pointer passed to `work` points to valid memory.\n\n\n```cpp\n#include <string>\nvoid work(const char*);\n\n// GOOD: the concatenated string outlives the call to `work`. So the pointer\n// obtainted from `c_str` is valid.\nvoid work_with_combined_string_good(std::string s1, std::string s2) {\n  auto combined_string = s1 + s2;\n  work(combined_string.c_str());\n}\n```\n\n## References\n* [MEM50-CPP. Do not access freed memory](https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM50-CPP.+Do+not+access+freed+memory).\n* Microsoft Learn: [Temporary objects](https://learn.microsoft.com/en-us/cpp/cpp/temporary-objects?view=msvc-170).\n* cppreference.com: [Lifetime of a temporary](https://en.cppreference.com/w/cpp/language/reference_initialization#Lifetime_of_a_temporary).\n* Common Weakness Enumeration: [CWE-416](https://cwe.mitre.org/data/definitions/416.html).\n* Common Weakness Enumeration: [CWE-664](https://cwe.mitre.org/data/definitions/664.html).\n","markdown":"# Use of string after lifetime ends\nCalling `c_str` on a `std::string` object returns a pointer to the underlying character array. When the `std::string` object is destroyed, the pointer returned by `c_str` is no longer valid. If the pointer is used after the `std::string` object is destroyed, then the behavior is undefined.\n\nTypically, this problem occurs when a `std::string` is returned by a function call (or overloaded operator) by value, and the result is not immediately stored in a variable by value or reference in a way that extends the lifetime of the temporary object. The resulting temporary `std::string` object is destroyed at the end of the containing expression statement, along with any memory returned by a call to `c_str`.\n\n\n## Recommendation\nEnsure that the pointer returned by `c_str` does not outlive the underlying `std::string` object.\n\n\n## Example\nThe following example concatenates two `std::string` objects, and then converts the resulting string to a C string using `c_str` so that it can be passed to the `work` function. However, the underlying `std::string` object that represents the concatenated string is destroyed as soon as the call to `c_str` returns. This means that `work` is given a pointer to invalid memory.\n\n\n```cpp\n#include <string>\nvoid work(const char*);\n\n// BAD: the concatenated string is deallocated when `c_str` returns. So `work`\n// is given a pointer to invalid memory.\nvoid work_with_combined_string_bad(std::string s1, std::string s2) {\n  const char* combined_string = (s1 + s2).c_str();\n  work(combined_string);\n}\n```\nThe following example fixes the above code by ensuring that the pointer returned by the call to `c_str` does not outlive the underlying `std::string` objects. This ensures that the pointer passed to `work` points to valid memory.\n\n\n```cpp\n#include <string>\nvoid work(const char*);\n\n// GOOD: the concatenated string outlives the call to `work`. So the pointer\n// obtainted from `c_str` is valid.\nvoid work_with_combined_string_good(std::string s1, std::string s2) {\n  auto combined_string = s1 + s2;\n  work(combined_string.c_str());\n}\n```\n\n## References\n* [MEM50-CPP. Do not access freed memory](https://wiki.sei.cmu.edu/confluence/display/cplusplus/MEM50-CPP.+Do+not+access+freed+memory).\n* Microsoft Learn: [Temporary objects](https://learn.microsoft.com/en-us/cpp/cpp/temporary-objects?view=msvc-170).\n* cppreference.com: [Lifetime of a temporary](https://en.cppreference.com/w/cpp/language/reference_initialization#Lifetime_of_a_temporary).\n* Common Weakness Enumeration: [CWE-416](https://cwe.mitre.org/data/definitions/416.html).\n* Common Weakness Enumeration: [CWE-664](https://cwe.mitre.org/data/definitions/664.html).\n"},"properties":{"tags":["reliability","security","external/cwe/cwe-416","external/cwe/cwe-664"],"description":"If the value of a call to 'c_str' outlives the underlying object it may lead to unexpected behavior.","id":"cpp/use-of-string-after-lifetime-ends","kind":"problem","name":"Use of string after lifetime ends","precision":"high","problem.severity":"warning","security-severity":"8.8"}},{"id":"cpp/uncontrolled-arithmetic","name":"cpp/uncontrolled-arithmetic","shortDescription":{"text":"Uncontrolled data in arithmetic expression"},"fullDescription":{"text":"Arithmetic operations on uncontrolled data that is not validated can cause overflows."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Uncontrolled data in arithmetic expression\nPerforming calculations on uncontrolled data can result in integer overflows unless the input is validated.\n\nIf the data is not under your control, and can take extremely large values, even arithmetic operations that would usually result in a small change in magnitude may result in overflows.\n\n\n## Recommendation\nAlways guard against overflow in arithmetic operations on uncontrolled data by doing one of the following:\n\n* Validate the data.\n* Define a guard on the arithmetic expression, so that the operation is performed only if the result can be known to be less than, or equal to, the maximum value for the type, for example `INT_MAX`.\n* Use a wider type, so that larger input values do not cause overflow.\n\n## Example\nIn this example, a random integer is generated. Because the value is not controlled by the programmer, it could be extremely large. Performing arithmetic operations on this value could therefore cause an overflow. To avoid this happening, the example shows how to perform a check before performing an arithmetic operation.\n\n\n```c\nint main(int argc, char** argv) {\n\tint i = rand();\n\t// BAD: potential overflow\n\tint j = i + 1000;\n\n\t// ...\n\n\tint n = rand();\n\tint k;\n\t// GOOD: use a guard to prevent overflow\n\tif (n < INT_MAX-1000)\n\t\tk = n + 1000;\n\telse\n\t\tk = INT_MAX;\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-191](https://cwe.mitre.org/data/definitions/191.html).\n","markdown":"# Uncontrolled data in arithmetic expression\nPerforming calculations on uncontrolled data can result in integer overflows unless the input is validated.\n\nIf the data is not under your control, and can take extremely large values, even arithmetic operations that would usually result in a small change in magnitude may result in overflows.\n\n\n## Recommendation\nAlways guard against overflow in arithmetic operations on uncontrolled data by doing one of the following:\n\n* Validate the data.\n* Define a guard on the arithmetic expression, so that the operation is performed only if the result can be known to be less than, or equal to, the maximum value for the type, for example `INT_MAX`.\n* Use a wider type, so that larger input values do not cause overflow.\n\n## Example\nIn this example, a random integer is generated. Because the value is not controlled by the programmer, it could be extremely large. Performing arithmetic operations on this value could therefore cause an overflow. To avoid this happening, the example shows how to perform a check before performing an arithmetic operation.\n\n\n```c\nint main(int argc, char** argv) {\n\tint i = rand();\n\t// BAD: potential overflow\n\tint j = i + 1000;\n\n\t// ...\n\n\tint n = rand();\n\tint k;\n\t// GOOD: use a guard to prevent overflow\n\tif (n < INT_MAX-1000)\n\t\tk = n + 1000;\n\telse\n\t\tk = INT_MAX;\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-191](https://cwe.mitre.org/data/definitions/191.html).\n"},"properties":{"tags":["security","external/cwe/cwe-190","external/cwe/cwe-191"],"description":"Arithmetic operations on uncontrolled data that is not\n              validated can cause overflows.","id":"cpp/uncontrolled-arithmetic","kind":"path-problem","name":"Uncontrolled data in arithmetic expression","precision":"high","problem.severity":"warning","security-severity":"8.6"}},{"id":"cpp/comparison-with-wider-type","name":"cpp/comparison-with-wider-type","shortDescription":{"text":"Comparison of narrow type with wide type in loop condition"},"fullDescription":{"text":"Comparisons between types of different widths in a loop condition can cause the loop to behave unexpectedly."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Comparison of narrow type with wide type in loop condition\nIn a loop condition, comparison of a value of a narrow type with a value of a wide type may result in unexpected behavior if the wider value is sufficiently large (or small). This is because the narrower value may overflow. This can lead to an infinite loop.\n\n\n## Recommendation\nChange the types of the compared values so that the value on the narrower side of the comparison is at least as wide as the value it is being compared with.\n\n\n## Example\nIn this example, `bytes_received` is compared against `max_get` in a `while` loop. However, `bytes_received` is an `int16_t`, and `max_get` is an `int32_t`. Because `max_get` is larger than `INT16_MAX`, the loop condition is always `true`, so the loop never terminates.\n\nThis problem is avoided in the 'GOOD' case because `bytes_received2` is an `int32_t`, which is as wide as the type of `max_get`.\n\n\n```c\nvoid main(int argc, char **argv) {\n\tuint32_t big_num = INT32_MAX;\n\tchar buf[big_num];\n\tint16_t bytes_received = 0;\n\tint max_get = INT16_MAX + 1;\n\n\t// BAD: 'bytes_received' is compared with a value of a wider type.\n\t// 'bytes_received' overflows before  reaching 'max_get',\n\t// causing an infinite loop\n\twhile (bytes_received < max_get)\n\t\tbytes_received += get_from_input(buf, bytes_received);\n\t}\n\n\tuint32_t bytes_received = 0;\n\n\t// GOOD: 'bytes_received2' has a type  at least as wide as 'max_get'\n\twhile (bytes_received < max_get) {\n\t\tbytes_received += get_from_input(buf, bytes_received);\n\t}\n\n}\n\n\nint getFromInput(char *buf, short pos) {\n\t// write to buf\n\t// ...\n\treturn 1;\n}\n\n```\n\n## References\n* [Data type ranges](https://docs.microsoft.com/en-us/cpp/cpp/data-type-ranges)\n* [INT18-C. Evaluate integer expressions in a larger size before comparing or assigning to that size ](https://wiki.sei.cmu.edu/confluence/display/c/INT18-C.+Evaluate+integer+expressions+in+a+larger+size+before+comparing+or+assigning+to+that+size)\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-197](https://cwe.mitre.org/data/definitions/197.html).\n* Common Weakness Enumeration: [CWE-835](https://cwe.mitre.org/data/definitions/835.html).\n","markdown":"# Comparison of narrow type with wide type in loop condition\nIn a loop condition, comparison of a value of a narrow type with a value of a wide type may result in unexpected behavior if the wider value is sufficiently large (or small). This is because the narrower value may overflow. This can lead to an infinite loop.\n\n\n## Recommendation\nChange the types of the compared values so that the value on the narrower side of the comparison is at least as wide as the value it is being compared with.\n\n\n## Example\nIn this example, `bytes_received` is compared against `max_get` in a `while` loop. However, `bytes_received` is an `int16_t`, and `max_get` is an `int32_t`. Because `max_get` is larger than `INT16_MAX`, the loop condition is always `true`, so the loop never terminates.\n\nThis problem is avoided in the 'GOOD' case because `bytes_received2` is an `int32_t`, which is as wide as the type of `max_get`.\n\n\n```c\nvoid main(int argc, char **argv) {\n\tuint32_t big_num = INT32_MAX;\n\tchar buf[big_num];\n\tint16_t bytes_received = 0;\n\tint max_get = INT16_MAX + 1;\n\n\t// BAD: 'bytes_received' is compared with a value of a wider type.\n\t// 'bytes_received' overflows before  reaching 'max_get',\n\t// causing an infinite loop\n\twhile (bytes_received < max_get)\n\t\tbytes_received += get_from_input(buf, bytes_received);\n\t}\n\n\tuint32_t bytes_received = 0;\n\n\t// GOOD: 'bytes_received2' has a type  at least as wide as 'max_get'\n\twhile (bytes_received < max_get) {\n\t\tbytes_received += get_from_input(buf, bytes_received);\n\t}\n\n}\n\n\nint getFromInput(char *buf, short pos) {\n\t// write to buf\n\t// ...\n\treturn 1;\n}\n\n```\n\n## References\n* [Data type ranges](https://docs.microsoft.com/en-us/cpp/cpp/data-type-ranges)\n* [INT18-C. Evaluate integer expressions in a larger size before comparing or assigning to that size ](https://wiki.sei.cmu.edu/confluence/display/c/INT18-C.+Evaluate+integer+expressions+in+a+larger+size+before+comparing+or+assigning+to+that+size)\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-197](https://cwe.mitre.org/data/definitions/197.html).\n* Common Weakness Enumeration: [CWE-835](https://cwe.mitre.org/data/definitions/835.html).\n"},"properties":{"tags":["reliability","security","external/cwe/cwe-190","external/cwe/cwe-197","external/cwe/cwe-835"],"description":"Comparisons between types of different widths in a loop\n              condition can cause the loop to behave unexpectedly.","id":"cpp/comparison-with-wider-type","kind":"problem","name":"Comparison of narrow type with wide type in loop condition","precision":"high","problem.severity":"warning","security-severity":"7.8"}},{"id":"cpp/system-data-exposure","name":"cpp/system-data-exposure","shortDescription":{"text":"Exposure of system data to an unauthorized control sphere"},"fullDescription":{"text":"Exposing system data or debugging information helps a malicious user learn about the system and form an attack plan."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Exposure of system data to an unauthorized control sphere\nExposing system data or debugging information may help a malicious user learn about the system and form an attack plan. An attacker can use error messages that reveal technologies, operating systems, and product versions to tune their attack against known vulnerabilities in the software.\n\nThis query finds locations where system configuration information might be revealed to a remote user.\n\n\n## Recommendation\nDo not expose system configuration information to remote users. Be wary of the difference between information that could be helpful to users, and unnecessary details that could be useful to a malicious user.\n\n\n## Example\nIn this example the value of the `PATH` environment variable is revealed in full to the user when a particular error occurs. This might reveal information such as the software installed on your system to a malicious user who does not have legitimate access to that information.\n\n\n```cpp\nchar* path = getenv(\"PATH\");\n\n//...\n\nsprintf(buffer, \"Cannot find exe on path: %s\", path);\nsend(socket, buffer, strlen(buffer), 0);\n\n```\nThe message should be rephrased without this information, for example:\n\n\n```cpp\nchar* path = getenv(\"PATH\");\n\n//...\n\nmessage = \"An internal error has occurred. Please try again or contact a system administrator.\\n\";\nsend(socket, message, strlen(message), 0);\n```\n\n## References\n* Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).\n","markdown":"# Exposure of system data to an unauthorized control sphere\nExposing system data or debugging information may help a malicious user learn about the system and form an attack plan. An attacker can use error messages that reveal technologies, operating systems, and product versions to tune their attack against known vulnerabilities in the software.\n\nThis query finds locations where system configuration information might be revealed to a remote user.\n\n\n## Recommendation\nDo not expose system configuration information to remote users. Be wary of the difference between information that could be helpful to users, and unnecessary details that could be useful to a malicious user.\n\n\n## Example\nIn this example the value of the `PATH` environment variable is revealed in full to the user when a particular error occurs. This might reveal information such as the software installed on your system to a malicious user who does not have legitimate access to that information.\n\n\n```cpp\nchar* path = getenv(\"PATH\");\n\n//...\n\nsprintf(buffer, \"Cannot find exe on path: %s\", path);\nsend(socket, buffer, strlen(buffer), 0);\n\n```\nThe message should be rephrased without this information, for example:\n\n\n```cpp\nchar* path = getenv(\"PATH\");\n\n//...\n\nmessage = \"An internal error has occurred. Please try again or contact a system administrator.\\n\";\nsend(socket, message, strlen(message), 0);\n```\n\n## References\n* Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).\n"},"properties":{"tags":["security","external/cwe/cwe-497"],"description":"Exposing system data or debugging information helps\n              a malicious user learn about the system and form an\n              attack plan.","id":"cpp/system-data-exposure","kind":"path-problem","name":"Exposure of system data to an unauthorized control sphere","precision":"high","problem.severity":"warning","security-severity":"6.5"}},{"id":"cpp/hresult-boolean-conversion","name":"cpp/hresult-boolean-conversion","shortDescription":{"text":"Cast between HRESULT and a Boolean type"},"fullDescription":{"text":"Casting an HRESULT to/from a Boolean type and then using it in a test expression will yield an incorrect result because success (S_OK) in HRESULT is indicated by a value of 0."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Cast between HRESULT and a Boolean type\nThis query indicates that an `HRESULT` is being cast to a Boolean type or vice versa.\n\nThe typical success value (`S_OK`) of an `HRESULT` equals 0. However, 0 indicates failure for a Boolean type.\n\nCasting an `HRESULT` to a Boolean type and then using it in a test expression will yield an incorrect result.\n\n\n## Recommendation\nTo check if a call that returns an `HRESULT` succeeded use the `FAILED` macro.\n\n\n## Example\nIn the following example, `HRESULT` is used in a test expression incorrectly as it may yield an incorrect result.\n\n\n```cpp\nLPMALLOC pMalloc;\nHRESULT hr = CoGetMalloc(1, &pMalloc);\n\nif (!hr)\n{\n    // code ...\n}\n\n```\nTo fix this issue, use the `FAILED` macro in the test expression.\n\n\n## References\n* Common Weakness Enumeration: [CWE-253](https://cwe.mitre.org/data/definitions/253.html).\n","markdown":"# Cast between HRESULT and a Boolean type\nThis query indicates that an `HRESULT` is being cast to a Boolean type or vice versa.\n\nThe typical success value (`S_OK`) of an `HRESULT` equals 0. However, 0 indicates failure for a Boolean type.\n\nCasting an `HRESULT` to a Boolean type and then using it in a test expression will yield an incorrect result.\n\n\n## Recommendation\nTo check if a call that returns an `HRESULT` succeeded use the `FAILED` macro.\n\n\n## Example\nIn the following example, `HRESULT` is used in a test expression incorrectly as it may yield an incorrect result.\n\n\n```cpp\nLPMALLOC pMalloc;\nHRESULT hr = CoGetMalloc(1, &pMalloc);\n\nif (!hr)\n{\n    // code ...\n}\n\n```\nTo fix this issue, use the `FAILED` macro in the test expression.\n\n\n## References\n* Common Weakness Enumeration: [CWE-253](https://cwe.mitre.org/data/definitions/253.html).\n"},"properties":{"tags":["security","external/cwe/cwe-253"],"description":"Casting an HRESULT to/from a Boolean type and then using it in a test expression will yield an incorrect result because success (S_OK) in HRESULT is indicated by a value of 0.","id":"cpp/hresult-boolean-conversion","kind":"problem","name":"Cast between HRESULT and a Boolean type","precision":"high","problem.severity":"error","security-severity":"7.5"}},{"id":"cpp/no-space-for-terminator","name":"cpp/no-space-for-terminator","shortDescription":{"text":"No space for zero terminator"},"fullDescription":{"text":"Allocating a buffer using 'malloc' without ensuring that there is always space for the entire string and a zero terminator can cause a buffer overrun."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# No space for zero terminator\nThis rule identifies calls to `malloc` that call `strlen` to determine the required buffer size, but do not allocate space for the zero terminator.\n\n\n## Recommendation\nThe highlighted code segment creates a buffer without ensuring it's large enough to accommodate the copied data. This leaves the code susceptible to a buffer overflow attack, which could lead to anything from program crashes to malicious code execution.\n\nIncrease the size of the buffer being allocated by one or replace `malloc`, `strcpy` pairs with a call to `strdup`\n\n\n## Example\n\n```c\n\nvoid flawed_strdup(const char *input)\n{\n\tchar *copy;\n\n\t/* Fail to allocate space for terminating '\\0' */\n\tcopy = (char *)malloc(strlen(input));\n\tstrcpy(copy, input);\n\treturn copy;\n}\n\n\n```\n\n## References\n* CERT C Coding Standard: [MEM35-C. Allocate sufficient memory for an object](https://www.securecoding.cert.org/confluence/display/c/MEM35-C.+Allocate+sufficient+memory+for+an+object).\n* Common Weakness Enumeration: [CWE-131](https://cwe.mitre.org/data/definitions/131.html).\n* Common Weakness Enumeration: [CWE-120](https://cwe.mitre.org/data/definitions/120.html).\n* Common Weakness Enumeration: [CWE-122](https://cwe.mitre.org/data/definitions/122.html).\n","markdown":"# No space for zero terminator\nThis rule identifies calls to `malloc` that call `strlen` to determine the required buffer size, but do not allocate space for the zero terminator.\n\n\n## Recommendation\nThe highlighted code segment creates a buffer without ensuring it's large enough to accommodate the copied data. This leaves the code susceptible to a buffer overflow attack, which could lead to anything from program crashes to malicious code execution.\n\nIncrease the size of the buffer being allocated by one or replace `malloc`, `strcpy` pairs with a call to `strdup`\n\n\n## Example\n\n```c\n\nvoid flawed_strdup(const char *input)\n{\n\tchar *copy;\n\n\t/* Fail to allocate space for terminating '\\0' */\n\tcopy = (char *)malloc(strlen(input));\n\tstrcpy(copy, input);\n\treturn copy;\n}\n\n\n```\n\n## References\n* CERT C Coding Standard: [MEM35-C. Allocate sufficient memory for an object](https://www.securecoding.cert.org/confluence/display/c/MEM35-C.+Allocate+sufficient+memory+for+an+object).\n* Common Weakness Enumeration: [CWE-131](https://cwe.mitre.org/data/definitions/131.html).\n* Common Weakness Enumeration: [CWE-120](https://cwe.mitre.org/data/definitions/120.html).\n* Common Weakness Enumeration: [CWE-122](https://cwe.mitre.org/data/definitions/122.html).\n"},"properties":{"tags":["reliability","security","external/cwe/cwe-131","external/cwe/cwe-120","external/cwe/cwe-122"],"description":"Allocating a buffer using 'malloc' without ensuring that\n              there is always space for the entire string and a zero\n              terminator can cause a buffer overrun.","id":"cpp/no-space-for-terminator","kind":"problem","name":"No space for zero terminator","precision":"high","problem.severity":"error","security-severity":"9.8"}},{"id":"cpp/non-https-url","name":"cpp/non-https-url","shortDescription":{"text":"Failure to use HTTPS URLs"},"fullDescription":{"text":"Non-HTTPS connections can be intercepted by third parties."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Failure to use HTTPS URLs\nConstructing URLs with the HTTP protocol can lead to unsecured connections.\n\n\n## Recommendation\nWhen you construct a URL, ensure that you use an HTTPS URL rather than an HTTP URL. Then, any connections that are made using that URL are secure SSL connections.\n\n\n## Example\nThe following example shows two ways of opening a connection using a URL. When the connection is opened using an HTTP URL rather than an HTTPS URL, the connection is unsecured. When the connection is opened using an HTTPS URL, the connection is a secure SSL connection.\n\n\n```cpp\n\nvoid openUrl(char *url)\n{\n\t// ...\n}\n\nopenUrl(\"http://example.com\"); // BAD\n\nopenUrl(\"https://example.com\"); // GOOD: Opening a connection to a URL using HTTPS enforces SSL.\n\n```\n\n## References\n* OWASP: [Transport Layer Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html).\n* OWASP Top 10: [A08:2021 - Software and Data Integrity Failures](https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/).\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n* Common Weakness Enumeration: [CWE-345](https://cwe.mitre.org/data/definitions/345.html).\n","markdown":"# Failure to use HTTPS URLs\nConstructing URLs with the HTTP protocol can lead to unsecured connections.\n\n\n## Recommendation\nWhen you construct a URL, ensure that you use an HTTPS URL rather than an HTTP URL. Then, any connections that are made using that URL are secure SSL connections.\n\n\n## Example\nThe following example shows two ways of opening a connection using a URL. When the connection is opened using an HTTP URL rather than an HTTPS URL, the connection is unsecured. When the connection is opened using an HTTPS URL, the connection is a secure SSL connection.\n\n\n```cpp\n\nvoid openUrl(char *url)\n{\n\t// ...\n}\n\nopenUrl(\"http://example.com\"); // BAD\n\nopenUrl(\"https://example.com\"); // GOOD: Opening a connection to a URL using HTTPS enforces SSL.\n\n```\n\n## References\n* OWASP: [Transport Layer Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html).\n* OWASP Top 10: [A08:2021 - Software and Data Integrity Failures](https://owasp.org/Top10/A08_2021-Software_and_Data_Integrity_Failures/).\n* Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).\n* Common Weakness Enumeration: [CWE-345](https://cwe.mitre.org/data/definitions/345.html).\n"},"properties":{"tags":["security","external/cwe/cwe-319","external/cwe/cwe-345"],"description":"Non-HTTPS connections can be intercepted by third parties.","id":"cpp/non-https-url","kind":"path-problem","name":"Failure to use HTTPS URLs","precision":"high","problem.severity":"warning","security-severity":"8.1"}},{"id":"cpp/external-entity-expansion","name":"cpp/external-entity-expansion","shortDescription":{"text":"XML external entity expansion"},"fullDescription":{"text":"Parsing user-controlled XML documents and allowing expansion of external entity references may lead to disclosure of confidential data or denial of service."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# XML external entity expansion\nParsing untrusted XML files with a weakly configured XML parser may lead to an XML external entity (XXE) attack. This type of attack uses external entity references to access arbitrary files on a system, carry out denial-of-service (DoS) attacks, or server-side request forgery. Even when the result of parsing is not returned to the user, DoS attacks are still possible and out-of-band data retrieval techniques may allow attackers to steal sensitive data.\n\n\n## Recommendation\nThe easiest way to prevent XXE attacks is to disable external entity handling when parsing untrusted data. How this is done depends on the library being used. Note that some libraries, such as recent versions of `libxml`, disable entity expansion by default, so unless you have explicitly enabled entity expansion, no further action needs to be taken.\n\n\n## Example\nThe following example uses the `Xerces-C++` XML parser to parse a string `data`. If that string is from an untrusted source, this code may be vulnerable to an XXE attack, since the parser is constructed in its default state with `setDisableDefaultEntityResolution` set to `false`:\n\n\n```cpp\n\nXercesDOMParser *parser = new XercesDOMParser();\n\nparser->parse(data); // BAD (parser is not correctly configured, may expand external entity references)\n\n```\nTo guard against XXE attacks, the `setDisableDefaultEntityResolution` option should be set to `true`.\n\n\n```cpp\n\nXercesDOMParser *parser = new XercesDOMParser();\n\nparser->setDisableDefaultEntityResolution(true);\nparser->parse(data);\n\n```\n\n## References\n* OWASP: [XML External Entity (XXE) Processing](https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing).\n* OWASP: [XML External Entity Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html).\n* Timothy Morgen: [XML Schema, DTD, and Entity Attacks](https://research.nccgroup.com/2014/05/19/xml-schema-dtd-and-entity-attacks-a-compendium-of-known-techniques/).\n* Timur Yunusov, Alexey Osipov: [XML Out-Of-Band Data Retrieval](https://www.slideshare.net/qqlan/bh-ready-v4).\n* Common Weakness Enumeration: [CWE-611](https://cwe.mitre.org/data/definitions/611.html).\n","markdown":"# XML external entity expansion\nParsing untrusted XML files with a weakly configured XML parser may lead to an XML external entity (XXE) attack. This type of attack uses external entity references to access arbitrary files on a system, carry out denial-of-service (DoS) attacks, or server-side request forgery. Even when the result of parsing is not returned to the user, DoS attacks are still possible and out-of-band data retrieval techniques may allow attackers to steal sensitive data.\n\n\n## Recommendation\nThe easiest way to prevent XXE attacks is to disable external entity handling when parsing untrusted data. How this is done depends on the library being used. Note that some libraries, such as recent versions of `libxml`, disable entity expansion by default, so unless you have explicitly enabled entity expansion, no further action needs to be taken.\n\n\n## Example\nThe following example uses the `Xerces-C++` XML parser to parse a string `data`. If that string is from an untrusted source, this code may be vulnerable to an XXE attack, since the parser is constructed in its default state with `setDisableDefaultEntityResolution` set to `false`:\n\n\n```cpp\n\nXercesDOMParser *parser = new XercesDOMParser();\n\nparser->parse(data); // BAD (parser is not correctly configured, may expand external entity references)\n\n```\nTo guard against XXE attacks, the `setDisableDefaultEntityResolution` option should be set to `true`.\n\n\n```cpp\n\nXercesDOMParser *parser = new XercesDOMParser();\n\nparser->setDisableDefaultEntityResolution(true);\nparser->parse(data);\n\n```\n\n## References\n* OWASP: [XML External Entity (XXE) Processing](https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing).\n* OWASP: [XML External Entity Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html).\n* Timothy Morgen: [XML Schema, DTD, and Entity Attacks](https://research.nccgroup.com/2014/05/19/xml-schema-dtd-and-entity-attacks-a-compendium-of-known-techniques/).\n* Timur Yunusov, Alexey Osipov: [XML Out-Of-Band Data Retrieval](https://www.slideshare.net/qqlan/bh-ready-v4).\n* Common Weakness Enumeration: [CWE-611](https://cwe.mitre.org/data/definitions/611.html).\n"},"properties":{"tags":["security","external/cwe/cwe-611"],"description":"Parsing user-controlled XML documents and allowing expansion of\n              external entity references may lead to disclosure of\n              confidential data or denial of service.","id":"cpp/external-entity-expansion","kind":"path-problem","name":"XML external entity expansion","precision":"high","problem.severity":"warning","security-severity":"9.1"}},{"id":"cpp/open-call-with-mode-argument","name":"cpp/open-call-with-mode-argument","shortDescription":{"text":"File opened with O_CREAT flag but without mode argument"},"fullDescription":{"text":"Opening a file with the O_CREAT flag but without mode argument reads arbitrary bytes from the stack."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# File opened with O_CREAT flag but without mode argument\nWhen opening a file with the `O_CREAT` or `O_TMPFILE` flag, the `mode` must be supplied. If the `mode` argument is omitted, some arbitrary bytes from the stack will be used as the file mode. This leaks some bits from the stack into the permissions of the file.\n\n\n## Recommendation\nThe `mode` must be supplied when `O_CREAT` or `O_TMPFILE` is specified.\n\n\n## Example\nThe first example opens a file with the `O_CREAT` flag without supplying the `mode` argument. In this case arbitrary bytes from the stack will be used as `mode` argument. The second example correctly supplies the `mode` argument and creates a file that is user readable and writable.\n\n\n```c\nint open_file_bad() {\n\t// BAD - this uses arbitrary bytes from the stack as mode argument\n        return open(FILE, O_CREAT)\n}\n\nint open_file_good() {\n\t// GOOD - the mode argument is supplied\n        return open(FILE, O_CREAT, S_IRUSR | S_IWUSR)\n}\n\n```\n","markdown":"# File opened with O_CREAT flag but without mode argument\nWhen opening a file with the `O_CREAT` or `O_TMPFILE` flag, the `mode` must be supplied. If the `mode` argument is omitted, some arbitrary bytes from the stack will be used as the file mode. This leaks some bits from the stack into the permissions of the file.\n\n\n## Recommendation\nThe `mode` must be supplied when `O_CREAT` or `O_TMPFILE` is specified.\n\n\n## Example\nThe first example opens a file with the `O_CREAT` flag without supplying the `mode` argument. In this case arbitrary bytes from the stack will be used as `mode` argument. The second example correctly supplies the `mode` argument and creates a file that is user readable and writable.\n\n\n```c\nint open_file_bad() {\n\t// BAD - this uses arbitrary bytes from the stack as mode argument\n        return open(FILE, O_CREAT)\n}\n\nint open_file_good() {\n\t// GOOD - the mode argument is supplied\n        return open(FILE, O_CREAT, S_IRUSR | S_IWUSR)\n}\n\n```\n"},"properties":{"tags":["security","external/cwe/cwe-732"],"description":"Opening a file with the O_CREAT flag but without mode argument reads arbitrary bytes from the stack.","id":"cpp/open-call-with-mode-argument","kind":"problem","name":"File opened with O_CREAT flag but without mode argument","precision":"high","problem.severity":"error","security-severity":"7.8"}},{"id":"cpp/unsafe-dacl-security-descriptor","name":"cpp/unsafe-dacl-security-descriptor","shortDescription":{"text":"Setting a DACL to NULL in a SECURITY_DESCRIPTOR"},"fullDescription":{"text":"Setting a DACL to NULL in a SECURITY_DESCRIPTOR will result in an unprotected object. If the DACL that belongs to the security descriptor of an object is set to NULL, a null DACL is created. A null DACL grants full access to any user who requests it; normal security checking is not performed with respect to the object."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Setting a DACL to NULL in a SECURITY_DESCRIPTOR\nThis query indicates that a call is setting the DACL field in a `SECURITY_DESCRIPTOR` to null.\n\nWhen using `SetSecurityDescriptorDacl` to set a discretionary access control (DACL), setting the `bDaclPresent` argument to `TRUE` indicates the presence of a DACL in the security description in the argument `pDacl`.\n\nWhen the `pDacl` parameter does not point to a DACL (i.e. it is `NULL`) and the `bDaclPresent` flag is `TRUE`, a `NULL DACL` is specified.\n\nA `NULL DACL` grants full access to any user who requests it; normal security checking is not performed with respect to the object.\n\n\n## Recommendation\nYou should not use a `NULL DACL` with an object because any user can change the DACL and owner of the security descriptor.\n\n\n## Example\nIn the following example, the call to `SetSecurityDescriptorDacl` is setting an unsafe DACL (`NULL DACL`) to the security descriptor.\n\n\n```cpp\nSECURITY_DESCRIPTOR  pSD;\nSECURITY_ATTRIBUTES  SA;\n\nif (!InitializeSecurityDescriptor(&pSD, SECURITY_DESCRIPTOR_REVISION))\n{\n    // error handling\n}\nif (!SetSecurityDescriptorDacl(&pSD,\n    TRUE,   // bDaclPresent - this value indicates the presence of a DACL in the security descriptor\n    NULL,   // pDacl - the pDacl parameter does not point to a DACL. All access will be allowed\n    FALSE))\n{\n    // error handling\n}\n\n```\nTo fix this issue, `pDacl` argument should be a pointer to an `ACL` structure that specifies the DACL for the security descriptor.\n\n\n## References\n* [SetSecurityDescriptorDacl function (Microsoft documentation).](https://docs.microsoft.com/en-us/windows/desktop/api/securitybaseapi/nf-securitybaseapi-setsecuritydescriptordacl)\n* Common Weakness Enumeration: [CWE-732](https://cwe.mitre.org/data/definitions/732.html).\n","markdown":"# Setting a DACL to NULL in a SECURITY_DESCRIPTOR\nThis query indicates that a call is setting the DACL field in a `SECURITY_DESCRIPTOR` to null.\n\nWhen using `SetSecurityDescriptorDacl` to set a discretionary access control (DACL), setting the `bDaclPresent` argument to `TRUE` indicates the presence of a DACL in the security description in the argument `pDacl`.\n\nWhen the `pDacl` parameter does not point to a DACL (i.e. it is `NULL`) and the `bDaclPresent` flag is `TRUE`, a `NULL DACL` is specified.\n\nA `NULL DACL` grants full access to any user who requests it; normal security checking is not performed with respect to the object.\n\n\n## Recommendation\nYou should not use a `NULL DACL` with an object because any user can change the DACL and owner of the security descriptor.\n\n\n## Example\nIn the following example, the call to `SetSecurityDescriptorDacl` is setting an unsafe DACL (`NULL DACL`) to the security descriptor.\n\n\n```cpp\nSECURITY_DESCRIPTOR  pSD;\nSECURITY_ATTRIBUTES  SA;\n\nif (!InitializeSecurityDescriptor(&pSD, SECURITY_DESCRIPTOR_REVISION))\n{\n    // error handling\n}\nif (!SetSecurityDescriptorDacl(&pSD,\n    TRUE,   // bDaclPresent - this value indicates the presence of a DACL in the security descriptor\n    NULL,   // pDacl - the pDacl parameter does not point to a DACL. All access will be allowed\n    FALSE))\n{\n    // error handling\n}\n\n```\nTo fix this issue, `pDacl` argument should be a pointer to an `ACL` structure that specifies the DACL for the security descriptor.\n\n\n## References\n* [SetSecurityDescriptorDacl function (Microsoft documentation).](https://docs.microsoft.com/en-us/windows/desktop/api/securitybaseapi/nf-securitybaseapi-setsecuritydescriptordacl)\n* Common Weakness Enumeration: [CWE-732](https://cwe.mitre.org/data/definitions/732.html).\n"},"properties":{"tags":["security","external/cwe/cwe-732"],"description":"Setting a DACL to NULL in a SECURITY_DESCRIPTOR will result in an unprotected object.\n              If the DACL that belongs to the security descriptor of an object is set to NULL, a null DACL is created.\n              A null DACL grants full access to any user who requests it;\n              normal security checking is not performed with respect to the object.","id":"cpp/unsafe-dacl-security-descriptor","kind":"problem","name":"Setting a DACL to NULL in a SECURITY_DESCRIPTOR","precision":"high","problem.severity":"error","security-severity":"7.8"}},{"id":"cpp/dangerous-cin","name":"cpp/dangerous-cin","shortDescription":{"text":"Dangerous use of 'cin'"},"fullDescription":{"text":"Using `cin` without specifying the length of the input may be dangerous."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Dangerous use of 'cin'\nThis rule finds calls to `std::istream::operator>>` on `std::cin` without a preceding call to `cin.width`. Consuming input from `cin` without specifying the length of the input is dangerous due to the possibility of buffer overflows.\n\n\n## Recommendation\nAlways specify the length of any input expected from `cin` by calling `cin.width` before consuming the input.\n\n\n## Example\nThe following example shows both a dangerous and a safe way to consume input from `cin`.\n\n\n```cpp\n#define BUFFER_SIZE 20\n\nvoid bad()\n{\n\tchar buffer[BUFFER_SIZE];\n\t// BAD: Use of 'cin' without specifying the length of the input.\n\tcin >> buffer;\n\tbuffer[BUFFER_SIZE-1] = '\\0';\n}\n\nvoid good()\n{\n\tchar buffer[BUFFER_SIZE];\n\t// GOOD: Specifying the length of the input before using 'cin'.\n\tcin.width(BUFFER_SIZE);\n\tcin >> buffer;\n\tbuffer[BUFFER_SIZE-1] = '\\0';\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-676](https://cwe.mitre.org/data/definitions/676.html).\n","markdown":"# Dangerous use of 'cin'\nThis rule finds calls to `std::istream::operator>>` on `std::cin` without a preceding call to `cin.width`. Consuming input from `cin` without specifying the length of the input is dangerous due to the possibility of buffer overflows.\n\n\n## Recommendation\nAlways specify the length of any input expected from `cin` by calling `cin.width` before consuming the input.\n\n\n## Example\nThe following example shows both a dangerous and a safe way to consume input from `cin`.\n\n\n```cpp\n#define BUFFER_SIZE 20\n\nvoid bad()\n{\n\tchar buffer[BUFFER_SIZE];\n\t// BAD: Use of 'cin' without specifying the length of the input.\n\tcin >> buffer;\n\tbuffer[BUFFER_SIZE-1] = '\\0';\n}\n\nvoid good()\n{\n\tchar buffer[BUFFER_SIZE];\n\t// GOOD: Specifying the length of the input before using 'cin'.\n\tcin.width(BUFFER_SIZE);\n\tcin >> buffer;\n\tbuffer[BUFFER_SIZE-1] = '\\0';\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-676](https://cwe.mitre.org/data/definitions/676.html).\n"},"properties":{"tags":["reliability","security","external/cwe/cwe-676"],"description":"Using `cin` without specifying the length of the input\n              may be dangerous.","id":"cpp/dangerous-cin","kind":"problem","name":"Dangerous use of 'cin'","precision":"high","problem.severity":"error","security-severity":"10.0"}},{"id":"cpp/dangerous-function-overflow","name":"cpp/dangerous-function-overflow","shortDescription":{"text":"Use of dangerous function"},"fullDescription":{"text":"Use of a standard library function that does not guard against buffer overflow."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Use of dangerous function\nThis rule finds calls to the `gets` function, which is dangerous and should not be used. See **Related rules** below for rules that identify other dangerous functions.\n\nThe `gets` function is one of the vulnerabilities exploited by the Internet Worm of 1988, one of the first computer worms to spread through the Internet. The `gets` function provides no way to limit the amount of data that is read and stored, so without prior knowledge of the input it is impossible to use it safely with any size of buffer.\n\n\n## Recommendation\nReplace calls to `gets` with `fgets`, specifying the maximum length to copy. This will prevent the buffer overflow.\n\n\n## Example\nThe following example gets a string from standard input in two ways:\n\n\n```c\n#define BUFFERSIZE (1024)\n\n// BAD: using gets\nvoid echo_bad() {\n    char buffer[BUFFERSIZE];\n    gets(buffer);\n    printf(\"Input was: '%s'\\n\", buffer);\n}\n\n// GOOD: using fgets\nvoid echo_good() {\n    char buffer[BUFFERSIZE];\n    fgets(buffer, BUFFERSIZE, stdin);\n    printf(\"Input was: '%s'\\n\", buffer);\n}\n\n```\nThe first version uses `gets` and will overflow if the input is longer than the buffer. The second version of the code uses `fgets` and will not overflow, because the amount of data written is limited by the length parameter.\n\n\n## Related rules\nOther dangerous functions identified by CWE-676 (\"Use of Potentially Dangerous Function\") include `strcpy` and `strcat`. Use of these functions is highlighted by rules for the following CWEs:\n\n* [CWE-120 Classic Buffer Overflow](https://cwe.mitre.org/data/definitions/120.html).\n* [CWE-131 Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html).\n\n## References\n* Wikipedia: [Morris worm](http://en.wikipedia.org/wiki/Morris_worm).\n* E. Spafford. *The Internet Worm Program: An Analysis*. Purdue Technical Report CSD-TR-823, [(online)](http://www.textfiles.com/100/tr823.txt), 1988.\n* Common Weakness Enumeration: [CWE-242](https://cwe.mitre.org/data/definitions/242.html).\n* Common Weakness Enumeration: [CWE-676](https://cwe.mitre.org/data/definitions/676.html).\n","markdown":"# Use of dangerous function\nThis rule finds calls to the `gets` function, which is dangerous and should not be used. See **Related rules** below for rules that identify other dangerous functions.\n\nThe `gets` function is one of the vulnerabilities exploited by the Internet Worm of 1988, one of the first computer worms to spread through the Internet. The `gets` function provides no way to limit the amount of data that is read and stored, so without prior knowledge of the input it is impossible to use it safely with any size of buffer.\n\n\n## Recommendation\nReplace calls to `gets` with `fgets`, specifying the maximum length to copy. This will prevent the buffer overflow.\n\n\n## Example\nThe following example gets a string from standard input in two ways:\n\n\n```c\n#define BUFFERSIZE (1024)\n\n// BAD: using gets\nvoid echo_bad() {\n    char buffer[BUFFERSIZE];\n    gets(buffer);\n    printf(\"Input was: '%s'\\n\", buffer);\n}\n\n// GOOD: using fgets\nvoid echo_good() {\n    char buffer[BUFFERSIZE];\n    fgets(buffer, BUFFERSIZE, stdin);\n    printf(\"Input was: '%s'\\n\", buffer);\n}\n\n```\nThe first version uses `gets` and will overflow if the input is longer than the buffer. The second version of the code uses `fgets` and will not overflow, because the amount of data written is limited by the length parameter.\n\n\n## Related rules\nOther dangerous functions identified by CWE-676 (\"Use of Potentially Dangerous Function\") include `strcpy` and `strcat`. Use of these functions is highlighted by rules for the following CWEs:\n\n* [CWE-120 Classic Buffer Overflow](https://cwe.mitre.org/data/definitions/120.html).\n* [CWE-131 Incorrect Calculation of Buffer Size](https://cwe.mitre.org/data/definitions/131.html).\n\n## References\n* Wikipedia: [Morris worm](http://en.wikipedia.org/wiki/Morris_worm).\n* E. Spafford. *The Internet Worm Program: An Analysis*. Purdue Technical Report CSD-TR-823, [(online)](http://www.textfiles.com/100/tr823.txt), 1988.\n* Common Weakness Enumeration: [CWE-242](https://cwe.mitre.org/data/definitions/242.html).\n* Common Weakness Enumeration: [CWE-676](https://cwe.mitre.org/data/definitions/676.html).\n"},"properties":{"tags":["reliability","security","external/cwe/cwe-242","external/cwe/cwe-676"],"description":"Use of a standard library function that does not guard against buffer overflow.","id":"cpp/dangerous-function-overflow","kind":"problem","name":"Use of dangerous function","precision":"very-high","problem.severity":"error","security-severity":"10.0"}},{"id":"cpp/weak-cryptographic-algorithm","name":"cpp/weak-cryptographic-algorithm","shortDescription":{"text":"Use of a broken or risky cryptographic algorithm"},"fullDescription":{"text":"Using broken or weak cryptographic algorithms can allow an attacker to compromise security."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Use of a broken or risky cryptographic algorithm\nUsing broken or weak cryptographic algorithms can leave data vulnerable to being decrypted.\n\nMany cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that an attacker may be able to easily decrypt the encrypted data.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm. Use at least AES-128 or RSA-2048.\n\n\n## Example\nThe following code shows an example of using the `advapi` windows API to decrypt some data. When creating a key, you must specify which algorithm to use. The first example uses DES which is an older algorithm that is now considered weak. The second example uses AES, which is a strong modern algorithm.\n\n\n```c\nvoid advapi() {\n  HCRYPTPROV hCryptProv;\n  HCRYPTKEY hKey;\n  HCRYPTHASH hHash;\n  // other preparation goes here\n\n  // BAD: use 3DES for key\n  CryptDeriveKey(hCryptProv, CALG_3DES, hHash, 0, &hKey);\n\n  // GOOD: use AES\n  CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey);\n}\n\n\n```\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n","markdown":"# Use of a broken or risky cryptographic algorithm\nUsing broken or weak cryptographic algorithms can leave data vulnerable to being decrypted.\n\nMany cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that an attacker may be able to easily decrypt the encrypted data.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm. Use at least AES-128 or RSA-2048.\n\n\n## Example\nThe following code shows an example of using the `advapi` windows API to decrypt some data. When creating a key, you must specify which algorithm to use. The first example uses DES which is an older algorithm that is now considered weak. The second example uses AES, which is a strong modern algorithm.\n\n\n```c\nvoid advapi() {\n  HCRYPTPROV hCryptProv;\n  HCRYPTKEY hKey;\n  HCRYPTHASH hHash;\n  // other preparation goes here\n\n  // BAD: use 3DES for key\n  CryptDeriveKey(hCryptProv, CALG_3DES, hHash, 0, &hKey);\n\n  // GOOD: use AES\n  CryptDeriveKey(hCryptProv, CALG_AES_256, hHash, 0, &hKey);\n}\n\n\n```\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n"},"properties":{"tags":["security","external/cwe/cwe-327"],"description":"Using broken or weak cryptographic algorithms can allow\n              an attacker to compromise security.","id":"cpp/weak-cryptographic-algorithm","kind":"problem","name":"Use of a broken or risky cryptographic algorithm","precision":"high","problem.severity":"error","security-severity":"7.5"}},{"id":"cpp/openssl-heartbleed","name":"cpp/openssl-heartbleed","shortDescription":{"text":"Use of a version of OpenSSL with Heartbleed"},"fullDescription":{"text":"Using an old version of OpenSSL can allow remote attackers to retrieve portions of memory."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Use of a version of OpenSSL with Heartbleed\nEarlier versions of the popular OpenSSL library suffer from a buffer overflow in its \"heartbeat\" code. Because of the location of the problematic code, this vulnerability is often called \"Heartbleed\".\n\nSoftware that includes a copy of OpenSSL should be sure to use a current version of the library. If it uses an older version, it will be vulnerable to any network site it connects with.\n\n\n## Recommendation\nUpgrade to the latest version of OpenSSL. This problem was fixed in version 1.0.1g.\n\n\n## Example\nThe following code is present in earlier versions of OpenSSL. The `payload` variable is the number of bytes that should be copied from the request back into the response. The call to `memcpy` does this copy. The problem is that `payload` is supplied as part of the remote request, and there is no code that checks the size of it. If the caller supplies a very large value, then the `memcpy` call will copy memory that is outside the request packet.\n\n\n```c\nint\ntls1_process_heartbeat(SSL *s)\n    {\n    unsigned char *p = &s->s3->rrec.data[0], *pl;\n    unsigned short hbtype;\n    unsigned int payload;\n \n    /* ... */\n \n    hbtype = *p++;\n    n2s(p, payload);\n    pl = p;\n \n    /* ... */\n \n    if (hbtype == TLS1_HB_REQUEST)\n            {\n            /* ... */\n            memcpy(bp, pl, payload);  // BAD: overflow here\n            /* ... */\n            }\n \n \n    /* ... */\n \n    }\n\n```\n\n## References\n* Common Vulnerabilities and Exposures: [CVE-2014-0160](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0160).\n* OpenSSL News: [OpenSSL Security Advisory \\[07 Apr 2014\\]](https://www.openssl.org/news/secadv_20140407.txt).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n* Common Weakness Enumeration: [CWE-788](https://cwe.mitre.org/data/definitions/788.html).\n","markdown":"# Use of a version of OpenSSL with Heartbleed\nEarlier versions of the popular OpenSSL library suffer from a buffer overflow in its \"heartbeat\" code. Because of the location of the problematic code, this vulnerability is often called \"Heartbleed\".\n\nSoftware that includes a copy of OpenSSL should be sure to use a current version of the library. If it uses an older version, it will be vulnerable to any network site it connects with.\n\n\n## Recommendation\nUpgrade to the latest version of OpenSSL. This problem was fixed in version 1.0.1g.\n\n\n## Example\nThe following code is present in earlier versions of OpenSSL. The `payload` variable is the number of bytes that should be copied from the request back into the response. The call to `memcpy` does this copy. The problem is that `payload` is supplied as part of the remote request, and there is no code that checks the size of it. If the caller supplies a very large value, then the `memcpy` call will copy memory that is outside the request packet.\n\n\n```c\nint\ntls1_process_heartbeat(SSL *s)\n    {\n    unsigned char *p = &s->s3->rrec.data[0], *pl;\n    unsigned short hbtype;\n    unsigned int payload;\n \n    /* ... */\n \n    hbtype = *p++;\n    n2s(p, payload);\n    pl = p;\n \n    /* ... */\n \n    if (hbtype == TLS1_HB_REQUEST)\n            {\n            /* ... */\n            memcpy(bp, pl, payload);  // BAD: overflow here\n            /* ... */\n            }\n \n \n    /* ... */\n \n    }\n\n```\n\n## References\n* Common Vulnerabilities and Exposures: [CVE-2014-0160](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0160).\n* OpenSSL News: [OpenSSL Security Advisory \\[07 Apr 2014\\]](https://www.openssl.org/news/secadv_20140407.txt).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n* Common Weakness Enumeration: [CWE-788](https://cwe.mitre.org/data/definitions/788.html).\n"},"properties":{"tags":["security","external/cwe/cwe-327","external/cwe/cwe-788"],"description":"Using an old version of OpenSSL can allow remote\n              attackers to retrieve portions of memory.","id":"cpp/openssl-heartbleed","kind":"problem","name":"Use of a version of OpenSSL with Heartbleed","precision":"very-high","problem.severity":"error","security-severity":"7.5"}},{"id":"cpp/cgi-xss","name":"cpp/cgi-xss","shortDescription":{"text":"CGI script vulnerable to cross-site scripting"},"fullDescription":{"text":"Writing user input directly to a web page allows for a cross-site scripting vulnerability."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# CGI script vulnerable to cross-site scripting\nDirectly writing an HTTP request parameter back to a web page allows for a cross-site scripting vulnerability. The data is displayed in a user's web browser as belonging to one site, but it is provided by some other site that the user browses to. In effect, such an attack allows one web site to insert content in the other one.\n\nFor web servers implemented with the Common Gateway Interface (CGI), HTTP parameters are supplied via the `QUERY_STRING` environment variable.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider escaping special characters before writing the HTTP parameter back to the page.\n\n\n## Example\nIn the following example, the `bad_server` writes a parameter directly back to the HTML page that the user will see. The `good_server` first escapes any HTML special characters before writing to the HTML page.\n\n\n```c\nvoid bad_server() {\n  char* query = getenv(\"QUERY_STRING\");\n  puts(\"<p>Query results for \");\n  // BAD: Printing out an HTTP parameter with no escaping\n  puts(query);\n  puts(\"\\n<p>\\n\");\n  puts(do_search(query));\n}\n\nvoid good_server() {\n  char* query = getenv(\"QUERY_STRING\");\n  puts(\"<p>Query results for \");\n  // GOOD: Escape HTML characters before adding to a page\n  char* query_escaped = escape_html(query);\n  puts(query_escaped);\n  free(query_escaped);\n\n  puts(\"\\n<p>\\n\");\n  puts(do_search(query));\n}\n\n```\n\n## References\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* IETF Tools: [The Common Gateway Specification (CGI)](http://tools.ietf.org/html/draft-robinson-www-interface-00).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n","markdown":"# CGI script vulnerable to cross-site scripting\nDirectly writing an HTTP request parameter back to a web page allows for a cross-site scripting vulnerability. The data is displayed in a user's web browser as belonging to one site, but it is provided by some other site that the user browses to. In effect, such an attack allows one web site to insert content in the other one.\n\nFor web servers implemented with the Common Gateway Interface (CGI), HTTP parameters are supplied via the `QUERY_STRING` environment variable.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider escaping special characters before writing the HTTP parameter back to the page.\n\n\n## Example\nIn the following example, the `bad_server` writes a parameter directly back to the HTML page that the user will see. The `good_server` first escapes any HTML special characters before writing to the HTML page.\n\n\n```c\nvoid bad_server() {\n  char* query = getenv(\"QUERY_STRING\");\n  puts(\"<p>Query results for \");\n  // BAD: Printing out an HTTP parameter with no escaping\n  puts(query);\n  puts(\"\\n<p>\\n\");\n  puts(do_search(query));\n}\n\nvoid good_server() {\n  char* query = getenv(\"QUERY_STRING\");\n  puts(\"<p>Query results for \");\n  // GOOD: Escape HTML characters before adding to a page\n  char* query_escaped = escape_html(query);\n  puts(query_escaped);\n  free(query_escaped);\n\n  puts(\"\\n<p>\\n\");\n  puts(do_search(query));\n}\n\n```\n\n## References\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* IETF Tools: [The Common Gateway Specification (CGI)](http://tools.ietf.org/html/draft-robinson-www-interface-00).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n"},"properties":{"tags":["security","external/cwe/cwe-079"],"description":"Writing user input directly to a web page\n              allows for a cross-site scripting vulnerability.","id":"cpp/cgi-xss","kind":"path-problem","name":"CGI script vulnerable to cross-site scripting","precision":"high","problem.severity":"error","security-severity":"6.1"}},{"id":"cpp/badly-bounded-write","name":"cpp/badly-bounded-write","shortDescription":{"text":"Badly bounded write"},"fullDescription":{"text":"Buffer write operations with a length parameter that does not match the size of the destination buffer may overflow."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Badly bounded write\nThe program performs a buffer copy or write operation with an incorrect upper limit on the size of the copy. A sufficiently long input will overflow the target buffer. In addition to causing program instability, techniques exist which may allow an attacker to use this vulnerability to execute arbitrary code.\n\n\n## Recommendation\nUse preprocessor defines to specify the size of buffers, and use the same defines as arguments to `strncpy`, `snprintf` etc. This technique will ensure that buffer sizes are always specified correctly so that no overflow occurs.\n\n\n## Example\n\n```c\nvoid congratulateUser(const char *userName)\n{\n\tchar buffer[80];\n\n\t// BAD: even though snprintf is used, this could overflow the buffer\n\t// because the size specified is too large.\n\tsnprintf(buffer, 256, \"Congratulations, %s!\", userName);\n\n\tMessageBox(hWnd, buffer, \"New Message\", MB_OK);\n}\n```\nIn this example, the developer has used `snprintf` to control the maximum number of characters that can be written to `buffer`. Unfortunately, perhaps due to modifications since the code was first written, a limited buffer overrun can still occur because the size argument to `snprintf` is larger than the actual size of the buffer.\n\nTo fix the problem, either the second argument to `snprintf` should be changed to 80, or the buffer extended to 256 characters. A further improvement is to use a preprocessor define so that the size is only specified in one place, potentially preventing future recurrence of this issue.\n\n\n## References\n* CERT C Coding Standard: [STR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator](https://www.securecoding.cert.org/confluence/display/c/STR31-C.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator).\n* CERT C++ Coding Standard: [STR50-CPP. Guarantee that storage for strings has sufficient space for character data and the null terminator](https://www.securecoding.cert.org/confluence/display/cplusplus/STR50-CPP.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator).\n* Common Weakness Enumeration: [CWE-120](https://cwe.mitre.org/data/definitions/120.html).\n* Common Weakness Enumeration: [CWE-787](https://cwe.mitre.org/data/definitions/787.html).\n* Common Weakness Enumeration: [CWE-805](https://cwe.mitre.org/data/definitions/805.html).\n","markdown":"# Badly bounded write\nThe program performs a buffer copy or write operation with an incorrect upper limit on the size of the copy. A sufficiently long input will overflow the target buffer. In addition to causing program instability, techniques exist which may allow an attacker to use this vulnerability to execute arbitrary code.\n\n\n## Recommendation\nUse preprocessor defines to specify the size of buffers, and use the same defines as arguments to `strncpy`, `snprintf` etc. This technique will ensure that buffer sizes are always specified correctly so that no overflow occurs.\n\n\n## Example\n\n```c\nvoid congratulateUser(const char *userName)\n{\n\tchar buffer[80];\n\n\t// BAD: even though snprintf is used, this could overflow the buffer\n\t// because the size specified is too large.\n\tsnprintf(buffer, 256, \"Congratulations, %s!\", userName);\n\n\tMessageBox(hWnd, buffer, \"New Message\", MB_OK);\n}\n```\nIn this example, the developer has used `snprintf` to control the maximum number of characters that can be written to `buffer`. Unfortunately, perhaps due to modifications since the code was first written, a limited buffer overrun can still occur because the size argument to `snprintf` is larger than the actual size of the buffer.\n\nTo fix the problem, either the second argument to `snprintf` should be changed to 80, or the buffer extended to 256 characters. A further improvement is to use a preprocessor define so that the size is only specified in one place, potentially preventing future recurrence of this issue.\n\n\n## References\n* CERT C Coding Standard: [STR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator](https://www.securecoding.cert.org/confluence/display/c/STR31-C.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator).\n* CERT C++ Coding Standard: [STR50-CPP. Guarantee that storage for strings has sufficient space for character data and the null terminator](https://www.securecoding.cert.org/confluence/display/cplusplus/STR50-CPP.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator).\n* Common Weakness Enumeration: [CWE-120](https://cwe.mitre.org/data/definitions/120.html).\n* Common Weakness Enumeration: [CWE-787](https://cwe.mitre.org/data/definitions/787.html).\n* Common Weakness Enumeration: [CWE-805](https://cwe.mitre.org/data/definitions/805.html).\n"},"properties":{"tags":["reliability","security","external/cwe/cwe-120","external/cwe/cwe-787","external/cwe/cwe-805"],"description":"Buffer write operations with a length parameter that\n              does not match the size of the destination buffer may\n              overflow.","id":"cpp/badly-bounded-write","kind":"problem","name":"Badly bounded write","precision":"high","problem.severity":"error","security-severity":"9.3"}},{"id":"cpp/very-likely-overrunning-write","name":"cpp/very-likely-overrunning-write","shortDescription":{"text":"Likely overrunning write"},"fullDescription":{"text":"Buffer write operations that do not control the length of data written may overflow"},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Likely overrunning write\nThe program performs a buffer copy or write operation with no upper limit on the size of the copy. By analyzing the bounds of the expressions involved, it appears that certain inputs will cause a buffer overflow to occur in this case. In addition to causing program instability, techniques exist which may allow an attacker to use this vulnerability to execute arbitrary code.\n\n\n## Recommendation\nAlways control the length of buffer copy and buffer write operations. `strncpy` should be used over `strcpy`, `snprintf` over `sprintf`, and in other cases 'n-variant' functions should be preferred.\n\n\n## Example\n\n```c\nint sayHello(uint32_t userId)\n{\n\tchar buffer[17];\n\n\tif (userId > 9999) return USER_ID_OUT_OF_BOUNDS;\n\n\t// BAD: this message overflows the buffer if userId >= 1000,\n\t// as no space for the null terminator was accounted for\n\tsprintf(buffer, \"Hello, user %d!\", userId);\n\n\tMessageBox(hWnd, buffer, \"New Message\", MB_OK);\n\t\n\treturn SUCCESS;\n}\n```\nIn this example, the call to `sprintf` writes a message of 14 characters (including the terminating null) plus the length of the string conversion of \\`userId\\` into a buffer with space for just 17 characters. While \\`userId\\` is checked to occupy no more than 4 characters when converted, there is no space in the buffer for the terminating null character if \\`userId &gt;= 1000\\`. In this case, the null character overflows the buffer resulting in undefined behavior.\n\nTo fix this issue these changes should be made:\n\n* Control the size of the buffer by declaring it with a compile time constant.\n* Preferably, replace the call to `sprintf` with `snprintf`, using the defined constant size of the buffer or \\`sizeof(buffer)\\` as maximum length to write. This will prevent the buffer overflow.\n* Increasing the buffer size to account for the full range of \\`userId\\` and the terminating null character.\n\n## References\n* CERT C Coding Standard: [STR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator](https://www.securecoding.cert.org/confluence/display/c/STR31-C.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator).\n* CERT C++ Coding Standard: [STR50-CPP. Guarantee that storage for strings has sufficient space for character data and the null terminator](https://www.securecoding.cert.org/confluence/display/cplusplus/STR50-CPP.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator).\n* Common Weakness Enumeration: [CWE-120](https://cwe.mitre.org/data/definitions/120.html).\n* Common Weakness Enumeration: [CWE-787](https://cwe.mitre.org/data/definitions/787.html).\n* Common Weakness Enumeration: [CWE-805](https://cwe.mitre.org/data/definitions/805.html).\n","markdown":"# Likely overrunning write\nThe program performs a buffer copy or write operation with no upper limit on the size of the copy. By analyzing the bounds of the expressions involved, it appears that certain inputs will cause a buffer overflow to occur in this case. In addition to causing program instability, techniques exist which may allow an attacker to use this vulnerability to execute arbitrary code.\n\n\n## Recommendation\nAlways control the length of buffer copy and buffer write operations. `strncpy` should be used over `strcpy`, `snprintf` over `sprintf`, and in other cases 'n-variant' functions should be preferred.\n\n\n## Example\n\n```c\nint sayHello(uint32_t userId)\n{\n\tchar buffer[17];\n\n\tif (userId > 9999) return USER_ID_OUT_OF_BOUNDS;\n\n\t// BAD: this message overflows the buffer if userId >= 1000,\n\t// as no space for the null terminator was accounted for\n\tsprintf(buffer, \"Hello, user %d!\", userId);\n\n\tMessageBox(hWnd, buffer, \"New Message\", MB_OK);\n\t\n\treturn SUCCESS;\n}\n```\nIn this example, the call to `sprintf` writes a message of 14 characters (including the terminating null) plus the length of the string conversion of \\`userId\\` into a buffer with space for just 17 characters. While \\`userId\\` is checked to occupy no more than 4 characters when converted, there is no space in the buffer for the terminating null character if \\`userId &gt;= 1000\\`. In this case, the null character overflows the buffer resulting in undefined behavior.\n\nTo fix this issue these changes should be made:\n\n* Control the size of the buffer by declaring it with a compile time constant.\n* Preferably, replace the call to `sprintf` with `snprintf`, using the defined constant size of the buffer or \\`sizeof(buffer)\\` as maximum length to write. This will prevent the buffer overflow.\n* Increasing the buffer size to account for the full range of \\`userId\\` and the terminating null character.\n\n## References\n* CERT C Coding Standard: [STR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator](https://www.securecoding.cert.org/confluence/display/c/STR31-C.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator).\n* CERT C++ Coding Standard: [STR50-CPP. Guarantee that storage for strings has sufficient space for character data and the null terminator](https://www.securecoding.cert.org/confluence/display/cplusplus/STR50-CPP.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator).\n* Common Weakness Enumeration: [CWE-120](https://cwe.mitre.org/data/definitions/120.html).\n* Common Weakness Enumeration: [CWE-787](https://cwe.mitre.org/data/definitions/787.html).\n* Common Weakness Enumeration: [CWE-805](https://cwe.mitre.org/data/definitions/805.html).\n"},"properties":{"tags":["reliability","security","external/cwe/cwe-120","external/cwe/cwe-787","external/cwe/cwe-805"],"description":"Buffer write operations that do not control the length\n              of data written may overflow","id":"cpp/very-likely-overrunning-write","kind":"problem","name":"Likely overrunning write","precision":"high","problem.severity":"error","security-severity":"9.3"}},{"id":"cpp/unsigned-difference-expression-compared-zero","name":"cpp/unsigned-difference-expression-compared-zero","shortDescription":{"text":"Unsigned difference expression compared to zero"},"fullDescription":{"text":"A subtraction with an unsigned result can never be negative. Using such an expression in a relational comparison with `0` is likely to be wrong."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Unsigned difference expression compared to zero\nThis rule finds relational comparisons between the result of an unsigned subtraction and the value `0`. Such comparisons are likely to be wrong as the value of an unsigned subtraction can never be negative. So the relational comparison ends up checking whether the result of the subtraction is equal to `0`. This is probably not what the programmer intended.\n\n\n## Recommendation\nIf a relational comparison is intended, consider casting the result of the subtraction to a signed type. If the intention was to test for equality, consider replacing the relational comparison with an equality test.\n\n\n## Example\n\n```c\nuint32_t limit = get_limit();\nuint32_t total = 0;\n\nwhile (limit - total > 0) { // BAD: if `total` is greater than `limit` this will underflow and continue executing the loop.\n  total += get_data();\n}\n\nwhile (total < limit) { // GOOD: never underflows here because there is no arithmetic.\n  total += get_data();\n}\n\nwhile ((int64_t)limit - total > 0) { // GOOD: never underflows here because the result always fits in an `int64_t`.\n  total += get_data();\n}\n\n```\n\n## References\n* SEI CERT C Coding Standard: [INT02-C. Understand integer conversion rules](https://wiki.sei.cmu.edu/confluence/display/c/INT02-C.+Understand+integer+conversion+rules).\n* Common Weakness Enumeration: [CWE-191](https://cwe.mitre.org/data/definitions/191.html).\n","markdown":"# Unsigned difference expression compared to zero\nThis rule finds relational comparisons between the result of an unsigned subtraction and the value `0`. Such comparisons are likely to be wrong as the value of an unsigned subtraction can never be negative. So the relational comparison ends up checking whether the result of the subtraction is equal to `0`. This is probably not what the programmer intended.\n\n\n## Recommendation\nIf a relational comparison is intended, consider casting the result of the subtraction to a signed type. If the intention was to test for equality, consider replacing the relational comparison with an equality test.\n\n\n## Example\n\n```c\nuint32_t limit = get_limit();\nuint32_t total = 0;\n\nwhile (limit - total > 0) { // BAD: if `total` is greater than `limit` this will underflow and continue executing the loop.\n  total += get_data();\n}\n\nwhile (total < limit) { // GOOD: never underflows here because there is no arithmetic.\n  total += get_data();\n}\n\nwhile ((int64_t)limit - total > 0) { // GOOD: never underflows here because the result always fits in an `int64_t`.\n  total += get_data();\n}\n\n```\n\n## References\n* SEI CERT C Coding Standard: [INT02-C. Understand integer conversion rules](https://wiki.sei.cmu.edu/confluence/display/c/INT02-C.+Understand+integer+conversion+rules).\n* Common Weakness Enumeration: [CWE-191](https://cwe.mitre.org/data/definitions/191.html).\n"},"properties":{"tags":["security","correctness","external/cwe/cwe-191"],"description":"A subtraction with an unsigned result can never be negative. Using such an expression in a relational comparison with `0` is likely to be wrong.","id":"cpp/unsigned-difference-expression-compared-zero","kind":"problem","name":"Unsigned difference expression compared to zero","precision":"high","problem.severity":"warning","security-severity":"9.8"}},{"id":"cpp/too-few-arguments","name":"cpp/too-few-arguments","shortDescription":{"text":"Call to function with fewer arguments than declared parameters"},"fullDescription":{"text":"A function call is passing fewer arguments than the number of declared parameters of the function. This may indicate that the code does not follow the author's intent. It is also a vulnerability, since the function is likely to operate on undefined data."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Call to function with fewer arguments than declared parameters\nA function is called with fewer arguments than there are parameters of the function.\n\nThis may indicate that an incorrect function is being called, or that the signature (parameter list) of the called function is not known to the author.\n\nIn C, function calls generally need to provide the same number of arguments as there are arguments to the function. (Variadic functions can accept additional arguments.) Providing fewer arguments than there are parameters is extremely dangerous, as the called function will nevertheless try to obtain the missing arguments' values, either from the stack or from machine registers. As a result, the function may behave unpredictably.\n\nIf the called function *modifies* a parameter corresponding to a missing argument, it may alter the state of the program upon its return. An attacker could use this to, for example, alter the control flow of the program to access forbidden resources.\n\n\n## Recommendation\nCall the function with the correct number of arguments.\n\n\n## Example\n\n```c\nvoid one_argument();\n\nvoid calls() {\n\tone_argument(1); // GOOD: `one_argument` will accept and use the argument\n\t\n\tone_argument(); // BAD: `one_argument` will receive an undefined value\n}\n\nvoid one_argument(int x);\n\n```\n\n## References\n* SEI CERT C Coding Standard: [ DCL20-C. Explicitly specify void when a function accepts no arguments ](https://wiki.sei.cmu.edu/confluence/display/c/DCL20-C.+Explicitly+specify+void+when+a+function+accepts+no+arguments)\n* Common Weakness Enumeration: [CWE-234](https://cwe.mitre.org/data/definitions/234.html).\n* Common Weakness Enumeration: [CWE-685](https://cwe.mitre.org/data/definitions/685.html).\n","markdown":"# Call to function with fewer arguments than declared parameters\nA function is called with fewer arguments than there are parameters of the function.\n\nThis may indicate that an incorrect function is being called, or that the signature (parameter list) of the called function is not known to the author.\n\nIn C, function calls generally need to provide the same number of arguments as there are arguments to the function. (Variadic functions can accept additional arguments.) Providing fewer arguments than there are parameters is extremely dangerous, as the called function will nevertheless try to obtain the missing arguments' values, either from the stack or from machine registers. As a result, the function may behave unpredictably.\n\nIf the called function *modifies* a parameter corresponding to a missing argument, it may alter the state of the program upon its return. An attacker could use this to, for example, alter the control flow of the program to access forbidden resources.\n\n\n## Recommendation\nCall the function with the correct number of arguments.\n\n\n## Example\n\n```c\nvoid one_argument();\n\nvoid calls() {\n\tone_argument(1); // GOOD: `one_argument` will accept and use the argument\n\t\n\tone_argument(); // BAD: `one_argument` will receive an undefined value\n}\n\nvoid one_argument(int x);\n\n```\n\n## References\n* SEI CERT C Coding Standard: [ DCL20-C. Explicitly specify void when a function accepts no arguments ](https://wiki.sei.cmu.edu/confluence/display/c/DCL20-C.+Explicitly+specify+void+when+a+function+accepts+no+arguments)\n* Common Weakness Enumeration: [CWE-234](https://cwe.mitre.org/data/definitions/234.html).\n* Common Weakness Enumeration: [CWE-685](https://cwe.mitre.org/data/definitions/685.html).\n"},"properties":{"tags":["correctness","maintainability","security","external/cwe/cwe-234","external/cwe/cwe-685"],"description":"A function call is passing fewer arguments than the number of\n              declared parameters of the function. This may indicate\n              that the code does not follow the author's intent. It is also\n              a vulnerability, since the function is likely to operate on\n              undefined data.","id":"cpp/too-few-arguments","kind":"problem","name":"Call to function with fewer arguments than declared parameters","precision":"very-high","problem.severity":"error","security-severity":"5.0"}},{"id":"cpp/redundant-null-check-simple","name":"cpp/redundant-null-check-simple","shortDescription":{"text":"Redundant null check due to previous dereference"},"fullDescription":{"text":"Checking a pointer for nullness after dereferencing it is likely to be a sign that either the check can be removed, or it should be moved before the dereference."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Redundant null check due to previous dereference\nThis rule finds comparisons of a pointer to null that occur after a reference of that pointer. It's likely either the check is not required and can be removed, or it should be moved to before the dereference so that a null pointer dereference does not occur.\n\n\n## Recommendation\nThe check should be moved to before the dereference, in a way that prevents a null pointer value from being dereferenced. If it's clear that the pointer cannot be null, consider removing the check instead.\n\n\n## Example\n\n```cpp\nint f(MyList *list) {\n\tlist->append(1);\n\n\t// ...\n\n\tif (list != NULL)\n\t{\n\t\tlist->append(2);\n\t}\n}\n\n```\n\n## References\n* [ Null Dereference ](https://www.owasp.org/index.php/Null_Dereference)\n* Common Weakness Enumeration: [CWE-476](https://cwe.mitre.org/data/definitions/476.html).\n","markdown":"# Redundant null check due to previous dereference\nThis rule finds comparisons of a pointer to null that occur after a reference of that pointer. It's likely either the check is not required and can be removed, or it should be moved to before the dereference so that a null pointer dereference does not occur.\n\n\n## Recommendation\nThe check should be moved to before the dereference, in a way that prevents a null pointer value from being dereferenced. If it's clear that the pointer cannot be null, consider removing the check instead.\n\n\n## Example\n\n```cpp\nint f(MyList *list) {\n\tlist->append(1);\n\n\t// ...\n\n\tif (list != NULL)\n\t{\n\t\tlist->append(2);\n\t}\n}\n\n```\n\n## References\n* [ Null Dereference ](https://www.owasp.org/index.php/Null_Dereference)\n* Common Weakness Enumeration: [CWE-476](https://cwe.mitre.org/data/definitions/476.html).\n"},"properties":{"tags":["reliability","correctness","security","external/cwe/cwe-476"],"description":"Checking a pointer for nullness after dereferencing it is\n              likely to be a sign that either the check can be removed, or\n              it should be moved before the dereference.","id":"cpp/redundant-null-check-simple","kind":"path-problem","name":"Redundant null check due to previous dereference","precision":"high","problem.severity":"error","security-severity":"7.5"}},{"id":"cpp/upcast-array-pointer-arithmetic","name":"cpp/upcast-array-pointer-arithmetic","shortDescription":{"text":"Upcast array used in pointer arithmetic"},"fullDescription":{"text":"An array with elements of a derived struct type is cast to a pointer to the base type of the struct. If pointer arithmetic or an array dereference is done on the resulting pointer, it will use the width of the base type, leading to misaligned reads."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Upcast array used in pointer arithmetic\nA pointer to a derived class may be implicitly converted to a pointer to its base type when passed as an argument to a function expecting a pointer to the base type. If pointer arithmetic or an array dereference is then used, it will be performed using the size of the base type. This can lead to reading data from unexpected fields in the derived type.\n\n\n## Recommendation\nOnly convert pointers to single objects. If you must work with a sequence of objects that are converted to a base type, use an array of pointers rather than a pointer to an array.\n\n\n## Example\n\n```cpp\nclass Base {\npublic:\n\tint x;\n}\n\nclass Derived: public Base {\npublic:\n\tint y;\n};\n\nvoid dereference_base(Base *b) {\n\tb[2].x;\n}\n\nvoid dereference_derived(Derived *d) {\n\td[2].x;\n}\n\nvoid test () {\n\tDerived[4] d;\n\tdereference_base(d); // BAD: implicit conversion to Base*\n\n\tdereference_derived(d); // GOOD: implicit conversion to Derived*, which will be the right size\n}\n\n```\n","markdown":"# Upcast array used in pointer arithmetic\nA pointer to a derived class may be implicitly converted to a pointer to its base type when passed as an argument to a function expecting a pointer to the base type. If pointer arithmetic or an array dereference is then used, it will be performed using the size of the base type. This can lead to reading data from unexpected fields in the derived type.\n\n\n## Recommendation\nOnly convert pointers to single objects. If you must work with a sequence of objects that are converted to a base type, use an array of pointers rather than a pointer to an array.\n\n\n## Example\n\n```cpp\nclass Base {\npublic:\n\tint x;\n}\n\nclass Derived: public Base {\npublic:\n\tint y;\n};\n\nvoid dereference_base(Base *b) {\n\tb[2].x;\n}\n\nvoid dereference_derived(Derived *d) {\n\td[2].x;\n}\n\nvoid test () {\n\tDerived[4] d;\n\tdereference_base(d); // BAD: implicit conversion to Base*\n\n\tdereference_derived(d); // GOOD: implicit conversion to Derived*, which will be the right size\n}\n\n```\n"},"properties":{"tags":["correctness","reliability","security","external/cwe/cwe-119","external/cwe/cwe-843"],"description":"An array with elements of a derived struct type is cast to a\n              pointer to the base type of the struct. If pointer arithmetic or\n              an array dereference is done on the resulting pointer, it will\n              use the width of the base type, leading to misaligned reads.","id":"cpp/upcast-array-pointer-arithmetic","kind":"path-problem","name":"Upcast array used in pointer arithmetic","precision":"high","problem.severity":"warning","security-severity":"9.3"}},{"id":"cpp/unsafe-use-of-this","name":"cpp/unsafe-use-of-this","shortDescription":{"text":"Unsafe use of this in constructor"},"fullDescription":{"text":"A call to a pure virtual function using a 'this' pointer of an object that is under construction may lead to undefined behavior."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Unsafe use of this in constructor\nThis rule finds calls to pure virtual member functions in constructors and destructors. When executing the body of a constructor of class `T`, the virtual table of `T` refers to the virtual table of one of `T`'s base classes. This can produce unexpected behavior, including program abort that can lead to denial of service attacks. The same problem exists during destruction of an object.\n\n\n## Recommendation\nDo not rely on virtual dispatch in constructors and destructors. Instead, each class should be responsible for acquiring and releasing its resources. If a base class needs to refer to a derived class during initialization, use the Dynamic Binding During Initialization idiom.\n\n\n## Example\n\n```cpp\nclass Base {\nprivate:\n    // pure virtual member function used for initialization of derived classes.\n    virtual void construct() = 0;\npublic:\n    Base() {\n        // wrong: the virtual table of `Derived` has not been initialized yet. So this\n        // call will resolve to `Base::construct`, which cannot be called as it is a pure\n        // virtual function.\n        construct();\n    }\n};\n\nclass Derived : public Base {\n    int field;\n\n    void construct() override {\n        field = 1;\n    }\n};\n\n```\n\n## References\n* ISO C++ FAQ: [When my base class's constructor calls a virtual function on its this object, why doesn't my derived class's override of that virtual function get invoked?](https://isocpp.org/wiki/faq/strange-inheritance#calling-virtuals-from-ctors)\n* SEI CERT C++ Coding Standard [OOP50-CPP. Do not invoke virtual functions from constructors or destructors](https://wiki.sei.cmu.edu/confluence/display/cplusplus/OOP50-CPP.+Do+not+invoke+virtual+functions+from+constructors+or+destructors)\n* ISO C++ FAQ: [Okay, but is there a way to simulate that behavior as if dynamic binding worked on the this object within my base class's constructor?](https://isocpp.org/wiki/faq/strange-inheritance#calling-virtuals-from-ctor-idiom)\n* Common Weakness Enumeration: [CWE-670](https://cwe.mitre.org/data/definitions/670.html).\n","markdown":"# Unsafe use of this in constructor\nThis rule finds calls to pure virtual member functions in constructors and destructors. When executing the body of a constructor of class `T`, the virtual table of `T` refers to the virtual table of one of `T`'s base classes. This can produce unexpected behavior, including program abort that can lead to denial of service attacks. The same problem exists during destruction of an object.\n\n\n## Recommendation\nDo not rely on virtual dispatch in constructors and destructors. Instead, each class should be responsible for acquiring and releasing its resources. If a base class needs to refer to a derived class during initialization, use the Dynamic Binding During Initialization idiom.\n\n\n## Example\n\n```cpp\nclass Base {\nprivate:\n    // pure virtual member function used for initialization of derived classes.\n    virtual void construct() = 0;\npublic:\n    Base() {\n        // wrong: the virtual table of `Derived` has not been initialized yet. So this\n        // call will resolve to `Base::construct`, which cannot be called as it is a pure\n        // virtual function.\n        construct();\n    }\n};\n\nclass Derived : public Base {\n    int field;\n\n    void construct() override {\n        field = 1;\n    }\n};\n\n```\n\n## References\n* ISO C++ FAQ: [When my base class's constructor calls a virtual function on its this object, why doesn't my derived class's override of that virtual function get invoked?](https://isocpp.org/wiki/faq/strange-inheritance#calling-virtuals-from-ctors)\n* SEI CERT C++ Coding Standard [OOP50-CPP. Do not invoke virtual functions from constructors or destructors](https://wiki.sei.cmu.edu/confluence/display/cplusplus/OOP50-CPP.+Do+not+invoke+virtual+functions+from+constructors+or+destructors)\n* ISO C++ FAQ: [Okay, but is there a way to simulate that behavior as if dynamic binding worked on the this object within my base class's constructor?](https://isocpp.org/wiki/faq/strange-inheritance#calling-virtuals-from-ctor-idiom)\n* Common Weakness Enumeration: [CWE-670](https://cwe.mitre.org/data/definitions/670.html).\n"},"properties":{"tags":["correctness","language-features","security","external/cwe/cwe-670"],"description":"A call to a pure virtual function using a 'this'\n              pointer of an object that is under construction\n              may lead to undefined behavior.","id":"cpp/unsafe-use-of-this","kind":"path-problem","name":"Unsafe use of this in constructor","precision":"very-high","problem.severity":"error","security-severity":"7.5"}},{"id":"cpp/integer-multiplication-cast-to-long","name":"cpp/integer-multiplication-cast-to-long","shortDescription":{"text":"Multiplication result converted to larger type"},"fullDescription":{"text":"A multiplication result that is converted to a larger type can be a sign that the result can overflow the type converted from."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Multiplication result converted to larger type\nThis rule finds code that converts the result of an integer multiplication to a larger type. Since the conversion applies *after* the multiplication, arithmetic overflow may still occur.\n\nThe rule flags every multiplication of two non-constant integer expressions that is (explicitly or implicitly) converted to a larger integer type. The conversion is an indication that the expression would produce a result that would be too large to fit in the smaller integer type.\n\n\n## Recommendation\nUse a cast to ensure that the multiplication is done using the larger integer type to avoid overflow.\n\n\n## Example\n\n```cpp\nint i = 2000000000;\nlong j = i * i; //Wrong: due to overflow on the multiplication between ints, \n                //will result to j being -1651507200, not 4000000000000000000\n\nlong k = (long) i * i; //Correct: the multiplication is done on longs instead of ints, \n                       //and will not overflow\n\nlong l = static_cast<long>(i) * i; //Correct: modern C++\n\n```\n\n## References\n* MSDN Library: [Multiplicative Operators and the Modulus Operator](https://docs.microsoft.com/en-us/cpp/cpp/multiplicative-operators-and-the-modulus-operator).\n* Cplusplus.com: [Integer overflow](http://www.cplusplus.com/articles/DE18T05o/).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-192](https://cwe.mitre.org/data/definitions/192.html).\n* Common Weakness Enumeration: [CWE-197](https://cwe.mitre.org/data/definitions/197.html).\n* Common Weakness Enumeration: [CWE-681](https://cwe.mitre.org/data/definitions/681.html).\n","markdown":"# Multiplication result converted to larger type\nThis rule finds code that converts the result of an integer multiplication to a larger type. Since the conversion applies *after* the multiplication, arithmetic overflow may still occur.\n\nThe rule flags every multiplication of two non-constant integer expressions that is (explicitly or implicitly) converted to a larger integer type. The conversion is an indication that the expression would produce a result that would be too large to fit in the smaller integer type.\n\n\n## Recommendation\nUse a cast to ensure that the multiplication is done using the larger integer type to avoid overflow.\n\n\n## Example\n\n```cpp\nint i = 2000000000;\nlong j = i * i; //Wrong: due to overflow on the multiplication between ints, \n                //will result to j being -1651507200, not 4000000000000000000\n\nlong k = (long) i * i; //Correct: the multiplication is done on longs instead of ints, \n                       //and will not overflow\n\nlong l = static_cast<long>(i) * i; //Correct: modern C++\n\n```\n\n## References\n* MSDN Library: [Multiplicative Operators and the Modulus Operator](https://docs.microsoft.com/en-us/cpp/cpp/multiplicative-operators-and-the-modulus-operator).\n* Cplusplus.com: [Integer overflow](http://www.cplusplus.com/articles/DE18T05o/).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-192](https://cwe.mitre.org/data/definitions/192.html).\n* Common Weakness Enumeration: [CWE-197](https://cwe.mitre.org/data/definitions/197.html).\n* Common Weakness Enumeration: [CWE-681](https://cwe.mitre.org/data/definitions/681.html).\n"},"properties":{"tags":["reliability","security","correctness","types","external/cwe/cwe-190","external/cwe/cwe-192","external/cwe/cwe-197","external/cwe/cwe-681"],"description":"A multiplication result that is converted to a larger type can\n              be a sign that the result can overflow the type converted from.","id":"cpp/integer-multiplication-cast-to-long","kind":"problem","name":"Multiplication result converted to larger type","precision":"high","problem.severity":"warning","security-severity":"8.1"}},{"id":"cpp/bad-addition-overflow-check","name":"cpp/bad-addition-overflow-check","shortDescription":{"text":"Bad check for overflow of integer addition"},"fullDescription":{"text":"Checking for overflow of integer addition by comparing against one of the arguments of the addition does not work when the result of the addition is automatically promoted to a larger type."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Bad check for overflow of integer addition\nChecking for overflow of integer addition needs to be done with care, because automatic type promotion can prevent the check from working as intended, with the same value (`true` or `false`) always being returned.\n\n\n## Recommendation\nUse an explicit cast to make sure that the result of the addition is not implicitly converted to a larger type.\n\n\n## Example\n\n```cpp\nbool checkOverflow(unsigned short x, unsigned short y) {\n  // BAD: comparison is always false due to type promotion\n  return (x + y < x);  \n}\n\n```\nOn a typical architecture where `short` is 16 bits and `int` is 32 bits, the operands of the addition are automatically promoted to `int`, so it cannot overflow and the result of the comparison is always false.\n\nThe code below implements the check correctly, by using an explicit cast to make sure that the result of the addition is `unsigned short` (which may overflow, in which case the comparison would evaluate to `true`).\n\n\n```cpp\nbool checkOverflow(unsigned short x, unsigned short y) {\n  return ((unsigned short)(x + y) < x);  // GOOD: explicit cast\n}\n\n```\n\n## References\n* [Preserving Rules](http://c-faq.com/expr/preservingrules.html)\n* [Understand integer conversion rules](https://www.securecoding.cert.org/confluence/plugins/servlet/mobile#content/view/20086942)\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-192](https://cwe.mitre.org/data/definitions/192.html).\n","markdown":"# Bad check for overflow of integer addition\nChecking for overflow of integer addition needs to be done with care, because automatic type promotion can prevent the check from working as intended, with the same value (`true` or `false`) always being returned.\n\n\n## Recommendation\nUse an explicit cast to make sure that the result of the addition is not implicitly converted to a larger type.\n\n\n## Example\n\n```cpp\nbool checkOverflow(unsigned short x, unsigned short y) {\n  // BAD: comparison is always false due to type promotion\n  return (x + y < x);  \n}\n\n```\nOn a typical architecture where `short` is 16 bits and `int` is 32 bits, the operands of the addition are automatically promoted to `int`, so it cannot overflow and the result of the comparison is always false.\n\nThe code below implements the check correctly, by using an explicit cast to make sure that the result of the addition is `unsigned short` (which may overflow, in which case the comparison would evaluate to `true`).\n\n\n```cpp\nbool checkOverflow(unsigned short x, unsigned short y) {\n  return ((unsigned short)(x + y) < x);  // GOOD: explicit cast\n}\n\n```\n\n## References\n* [Preserving Rules](http://c-faq.com/expr/preservingrules.html)\n* [Understand integer conversion rules](https://www.securecoding.cert.org/confluence/plugins/servlet/mobile#content/view/20086942)\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-192](https://cwe.mitre.org/data/definitions/192.html).\n"},"properties":{"tags":["reliability","correctness","security","external/cwe/cwe-190","external/cwe/cwe-192"],"description":"Checking for overflow of integer addition by comparing\n              against one of the arguments of the addition does not work\n              when the result of the addition is automatically promoted\n              to a larger type.","id":"cpp/bad-addition-overflow-check","kind":"problem","name":"Bad check for overflow of integer addition","precision":"very-high","problem.severity":"error","security-severity":"8.1"}},{"id":"cpp/signed-overflow-check","name":"cpp/signed-overflow-check","shortDescription":{"text":"Signed overflow check"},"fullDescription":{"text":"Testing for overflow by adding a value to a variable to see if it \"wraps around\" works only for unsigned integer values."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Signed overflow check\nWhen checking for integer overflow, you may often write tests like `a + b < a`. This works fine if `a` or `b` are unsigned integers, since any overflow in the addition will cause the value to simply \"wrap around.\" However, using *signed* integers is problematic because signed overflow has undefined behavior according to the C and C++ standards. If the addition overflows and has an undefined result, the comparison will likewise be undefined; it may produce an unintended result, or may be deleted entirely by an optimizing compiler.\n\n\n## Recommendation\nSolutions to this problem can be thought of as falling into one of two categories:\n\n1. Rewrite the signed expression so that overflow cannot occur but the signedness remains.\n1. Change the variables and all their uses to be unsigned.\nThe following cases all fall into the first category.\n\n1. Given `unsigned short n1, delta` and `n1 + delta < n1`, it is possible to rewrite it as `(unsigned short)(n1 + delta)&nbsp;<&nbsp;n1`. Note that `n1 + delta` does not actually overflow, due to `int` promotion.\n1. Given `unsigned short n1, delta` and `n1 + delta < n1`, it is also possible to rewrite it as `n1 > USHORT_MAX - delta`. The `limits.h` or `climits` header must then be included.\n1. Given `int n1, delta` and `n1 + delta < n1`, it is possible to rewrite it as `n1 > INT_MAX - delta`. It must be true that `delta >= 0` and the `limits.h` or `climits` header has been included.\n\n## Example\nIn the following example, even though `delta` has been declared `unsigned short`, C/C++ type promotion rules require that its type is promoted to the larger type used in the addition and comparison, namely a `signed int`. Addition is performed on signed integers, and may have undefined behavior if an overflow occurs. As a result, the entire (comparison) expression may also have an undefined result.\n\n\n```cpp\nbool foo(int n1, unsigned short delta) {\n    return n1 + delta < n1; // BAD\n}\n\n```\nThe following example builds upon the previous one. Instead of performing an addition (which could overflow), we have re-framed the solution so that a subtraction is used instead. Since `delta` is promoted to a `signed int` and `INT_MAX` denotes the largest possible positive value for an `signed int`, the expression `INT_MAX - delta` can never be less than zero or more than `INT_MAX`. Hence, any overflow and underflow are avoided.\n\n\n```cpp\n#include <limits.h>\nbool foo(int n1, unsigned short delta) {\n    return n1 > INT_MAX - delta; // GOOD\n}\n\n```\nIn the following example, even though both `n` and `delta` have been declared `unsigned short`, both are promoted to `signed int` prior to addition. Because we started out with the narrower `short` type, the addition is guaranteed not to overflow and is therefore defined. But the fact that `n1 + delta` never overflows means that the condition `n1 + delta < n1` will never hold true, which likely is not what the programmer intended. (see also the `cpp/bad-addition-overflow-check` query).\n\n\n```cpp\nbool bar(unsigned short n1, unsigned short delta) {\n    // NB: Comparison is always false\n    return n1 + delta < n1; // GOOD (but misleading)\n}\n\n```\nThe next example provides a solution to the previous one. Even though `n1 + delta` does not overflow, casting it to an `unsigned short` truncates the addition modulo 2^16, so that `unsigned short` \"wrap around\" may now be observed. Furthermore, since the left-hand side is now of type `unsigned short`, the right-hand side does not need to be promoted to a `signed int`.\n\n\n```cpp\nbool bar(unsigned short n1, unsigned short delta) {\n    return (unsigned short)(n1 + delta) < n1; // GOOD\n}\n\n```\n\n## References\n* [comp.lang.c FAQ list  Question 3.19 (Preserving rules)](http://c-faq.com/expr/preservingrules.html)\n* [INT31-C. Ensure that integer conversions do not result in lost or misinterpreted data](https://wiki.sei.cmu.edu/confluence/display/c/INT31-C.+Ensure+that+integer+conversions+do+not+result+in+lost+or+misinterpreted+data)\n* W. Dietz, P. Li, J. Regehr, V. Adve. [Understanding Integer Overflow in C/C++](https://www.cs.utah.edu/~regehr/papers/overflow12.pdf)\n* Common Weakness Enumeration: [CWE-128](https://cwe.mitre.org/data/definitions/128.html).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n","markdown":"# Signed overflow check\nWhen checking for integer overflow, you may often write tests like `a + b < a`. This works fine if `a` or `b` are unsigned integers, since any overflow in the addition will cause the value to simply \"wrap around.\" However, using *signed* integers is problematic because signed overflow has undefined behavior according to the C and C++ standards. If the addition overflows and has an undefined result, the comparison will likewise be undefined; it may produce an unintended result, or may be deleted entirely by an optimizing compiler.\n\n\n## Recommendation\nSolutions to this problem can be thought of as falling into one of two categories:\n\n1. Rewrite the signed expression so that overflow cannot occur but the signedness remains.\n1. Change the variables and all their uses to be unsigned.\nThe following cases all fall into the first category.\n\n1. Given `unsigned short n1, delta` and `n1 + delta < n1`, it is possible to rewrite it as `(unsigned short)(n1 + delta)&nbsp;<&nbsp;n1`. Note that `n1 + delta` does not actually overflow, due to `int` promotion.\n1. Given `unsigned short n1, delta` and `n1 + delta < n1`, it is also possible to rewrite it as `n1 > USHORT_MAX - delta`. The `limits.h` or `climits` header must then be included.\n1. Given `int n1, delta` and `n1 + delta < n1`, it is possible to rewrite it as `n1 > INT_MAX - delta`. It must be true that `delta >= 0` and the `limits.h` or `climits` header has been included.\n\n## Example\nIn the following example, even though `delta` has been declared `unsigned short`, C/C++ type promotion rules require that its type is promoted to the larger type used in the addition and comparison, namely a `signed int`. Addition is performed on signed integers, and may have undefined behavior if an overflow occurs. As a result, the entire (comparison) expression may also have an undefined result.\n\n\n```cpp\nbool foo(int n1, unsigned short delta) {\n    return n1 + delta < n1; // BAD\n}\n\n```\nThe following example builds upon the previous one. Instead of performing an addition (which could overflow), we have re-framed the solution so that a subtraction is used instead. Since `delta` is promoted to a `signed int` and `INT_MAX` denotes the largest possible positive value for an `signed int`, the expression `INT_MAX - delta` can never be less than zero or more than `INT_MAX`. Hence, any overflow and underflow are avoided.\n\n\n```cpp\n#include <limits.h>\nbool foo(int n1, unsigned short delta) {\n    return n1 > INT_MAX - delta; // GOOD\n}\n\n```\nIn the following example, even though both `n` and `delta` have been declared `unsigned short`, both are promoted to `signed int` prior to addition. Because we started out with the narrower `short` type, the addition is guaranteed not to overflow and is therefore defined. But the fact that `n1 + delta` never overflows means that the condition `n1 + delta < n1` will never hold true, which likely is not what the programmer intended. (see also the `cpp/bad-addition-overflow-check` query).\n\n\n```cpp\nbool bar(unsigned short n1, unsigned short delta) {\n    // NB: Comparison is always false\n    return n1 + delta < n1; // GOOD (but misleading)\n}\n\n```\nThe next example provides a solution to the previous one. Even though `n1 + delta` does not overflow, casting it to an `unsigned short` truncates the addition modulo 2^16, so that `unsigned short` \"wrap around\" may now be observed. Furthermore, since the left-hand side is now of type `unsigned short`, the right-hand side does not need to be promoted to a `signed int`.\n\n\n```cpp\nbool bar(unsigned short n1, unsigned short delta) {\n    return (unsigned short)(n1 + delta) < n1; // GOOD\n}\n\n```\n\n## References\n* [comp.lang.c FAQ list  Question 3.19 (Preserving rules)](http://c-faq.com/expr/preservingrules.html)\n* [INT31-C. Ensure that integer conversions do not result in lost or misinterpreted data](https://wiki.sei.cmu.edu/confluence/display/c/INT31-C.+Ensure+that+integer+conversions+do+not+result+in+lost+or+misinterpreted+data)\n* W. Dietz, P. Li, J. Regehr, V. Adve. [Understanding Integer Overflow in C/C++](https://www.cs.utah.edu/~regehr/papers/overflow12.pdf)\n* Common Weakness Enumeration: [CWE-128](https://cwe.mitre.org/data/definitions/128.html).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n"},"properties":{"tags":["correctness","security","external/cwe/cwe-128","external/cwe/cwe-190"],"description":"Testing for overflow by adding a value to a variable\n              to see if it \"wraps around\" works only for\n              unsigned integer values.","id":"cpp/signed-overflow-check","kind":"problem","name":"Signed overflow check","precision":"high","problem.severity":"warning","security-severity":"8.1"}},{"id":"cpp/overflowing-snprintf","name":"cpp/overflowing-snprintf","shortDescription":{"text":"Potentially overflowing call to snprintf"},"fullDescription":{"text":"Using the return value from snprintf without proper checks can cause overflow."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Potentially overflowing call to snprintf\nThe return value of a call to `snprintf` is the number of characters that *would have* been written to the buffer assuming there was sufficient space. In the event that the operation reaches the end of the buffer and more than one character is discarded, the return value will be greater than the buffer size. This can cause incorrect behavior, for example:\n\n\n## Example\n\n```cpp\n#define BUF_SIZE (32)\n\nint main(int argc, char *argv[])\n{\n\tchar buffer[BUF_SIZE];\n\tsize_t pos = 0;\n\tint i;\n\n\tfor (i = 0; i < argc; i++)\n\t{\n\t\tpos += snprintf(buffer + pos, BUF_SIZE - pos, \"%s\", argv[i]);\n\t\t\t// BUF_SIZE - pos may overflow\n\t}\n}\n\n```\n\n## Recommendation\nThe return value of `snprintf` should always be checked if it is used, and values larger than the buffer size should be accounted for.\n\n\n## Example\n\n```cpp\n#define BUF_SIZE (32)\n\nint main(int argc, char *argv[])\n{\n\tchar buffer[BUF_SIZE];\n\tsize_t pos = 0;\n\tint i;\n\n\tfor (i = 0; i < argc; i++)\n\t{\n\t\tint n = snprintf(buffer + pos, BUF_SIZE - pos, \"%s\", argv[i]);\n\t\tif (n < 0 || n >= BUF_SIZE - pos)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tpos += n;\n\t}\n}\n\n```\n\n## References\n* cplusplus.com: [snprintf](http://www.cplusplus.com/reference/cstdio/snprintf/).\n* Red Hat Customer Portal: [The trouble with snprintf](https://access.redhat.com/blogs/766093/posts/1976193).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-253](https://cwe.mitre.org/data/definitions/253.html).\n","markdown":"# Potentially overflowing call to snprintf\nThe return value of a call to `snprintf` is the number of characters that *would have* been written to the buffer assuming there was sufficient space. In the event that the operation reaches the end of the buffer and more than one character is discarded, the return value will be greater than the buffer size. This can cause incorrect behavior, for example:\n\n\n## Example\n\n```cpp\n#define BUF_SIZE (32)\n\nint main(int argc, char *argv[])\n{\n\tchar buffer[BUF_SIZE];\n\tsize_t pos = 0;\n\tint i;\n\n\tfor (i = 0; i < argc; i++)\n\t{\n\t\tpos += snprintf(buffer + pos, BUF_SIZE - pos, \"%s\", argv[i]);\n\t\t\t// BUF_SIZE - pos may overflow\n\t}\n}\n\n```\n\n## Recommendation\nThe return value of `snprintf` should always be checked if it is used, and values larger than the buffer size should be accounted for.\n\n\n## Example\n\n```cpp\n#define BUF_SIZE (32)\n\nint main(int argc, char *argv[])\n{\n\tchar buffer[BUF_SIZE];\n\tsize_t pos = 0;\n\tint i;\n\n\tfor (i = 0; i < argc; i++)\n\t{\n\t\tint n = snprintf(buffer + pos, BUF_SIZE - pos, \"%s\", argv[i]);\n\t\tif (n < 0 || n >= BUF_SIZE - pos)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tpos += n;\n\t}\n}\n\n```\n\n## References\n* cplusplus.com: [snprintf](http://www.cplusplus.com/reference/cstdio/snprintf/).\n* Red Hat Customer Portal: [The trouble with snprintf](https://access.redhat.com/blogs/766093/posts/1976193).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-253](https://cwe.mitre.org/data/definitions/253.html).\n"},"properties":{"tags":["reliability","correctness","security","external/cwe/cwe-190","external/cwe/cwe-253"],"description":"Using the return value from snprintf without proper checks can cause overflow.","id":"cpp/overflowing-snprintf","kind":"problem","name":"Potentially overflowing call to snprintf","precision":"high","problem.severity":"warning","security-severity":"8.1"}},{"id":"cpp/wrong-type-format-argument","name":"cpp/wrong-type-format-argument","shortDescription":{"text":"Wrong type of arguments to formatting function"},"fullDescription":{"text":"Calling a printf-like function with the wrong type of arguments causes unpredictable behavior."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Wrong type of arguments to formatting function\nEach call to the `printf` function or a related function should include the type and sequence of arguments defined by the format. If the function is passed arguments of a different type or in a different sequence then the arguments are reinterpreted to fit the type and sequence expected, resulting in unpredictable behavior.\n\n\n## Recommendation\nReview the format and arguments expected by the highlighted function calls. Update either the format or the arguments so that the expected type and sequence of arguments are passed to the function.\n\n\n## Example\nIn the following example, the wrong format specifier is given for an integer format argument:\n\n\n```cpp\nint main() {\n  printf(\"%s\\n\", 42); // BAD: printf will treat 42 as a char*, will most likely segfault\n  return 0;\n}\n\n```\nThe corrected version uses `%i` as the format specifier for the integer format argument:\n\n\n```cpp\nint main() {\n  printf(\"%i\\n\", 42); // GOOD: printf will treat 42 as an int\n  return 0;\n}\n\n```\n\n## References\n* Microsoft Learn: [Format specification syntax: printf and wprintf functions](https://learn.microsoft.com/en-us/cpp/c-runtime-library/format-specification-syntax-printf-and-wprintf-functions?view=msvc-170).\n* cplusplus.com:[](https://cplusplus.com/reference/cstdio/printf/)printf\n* CERT C Coding Standard: [FIO47-C. Use valid format strings](https://wiki.sei.cmu.edu/confluence/display/c/FIO47-C.+Use+valid+format+strings).\n* Common Weakness Enumeration: [CWE-686](https://cwe.mitre.org/data/definitions/686.html).\n","markdown":"# Wrong type of arguments to formatting function\nEach call to the `printf` function or a related function should include the type and sequence of arguments defined by the format. If the function is passed arguments of a different type or in a different sequence then the arguments are reinterpreted to fit the type and sequence expected, resulting in unpredictable behavior.\n\n\n## Recommendation\nReview the format and arguments expected by the highlighted function calls. Update either the format or the arguments so that the expected type and sequence of arguments are passed to the function.\n\n\n## Example\nIn the following example, the wrong format specifier is given for an integer format argument:\n\n\n```cpp\nint main() {\n  printf(\"%s\\n\", 42); // BAD: printf will treat 42 as a char*, will most likely segfault\n  return 0;\n}\n\n```\nThe corrected version uses `%i` as the format specifier for the integer format argument:\n\n\n```cpp\nint main() {\n  printf(\"%i\\n\", 42); // GOOD: printf will treat 42 as an int\n  return 0;\n}\n\n```\n\n## References\n* Microsoft Learn: [Format specification syntax: printf and wprintf functions](https://learn.microsoft.com/en-us/cpp/c-runtime-library/format-specification-syntax-printf-and-wprintf-functions?view=msvc-170).\n* cplusplus.com:[](https://cplusplus.com/reference/cstdio/printf/)printf\n* CERT C Coding Standard: [FIO47-C. Use valid format strings](https://wiki.sei.cmu.edu/confluence/display/c/FIO47-C.+Use+valid+format+strings).\n* Common Weakness Enumeration: [CWE-686](https://cwe.mitre.org/data/definitions/686.html).\n"},"properties":{"tags":["reliability","correctness","security","external/cwe/cwe-686"],"description":"Calling a printf-like function with the wrong type of arguments causes unpredictable\n              behavior.","id":"cpp/wrong-type-format-argument","kind":"problem","name":"Wrong type of arguments to formatting function","precision":"high","problem.severity":"error","security-severity":"7.5"}},{"id":"cpp/wrong-number-format-arguments","name":"cpp/wrong-number-format-arguments","shortDescription":{"text":"Too few arguments to formatting function"},"fullDescription":{"text":"Calling a printf-like function with too few arguments can be a source of security issues."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Too few arguments to formatting function\nEach call to the `printf` function, or a related function, should include the number of arguments defined by the format. Passing the function more arguments than required is harmless (although it may be indicative of other defects). However, passing the function fewer arguments than are defined by the format can be a security vulnerability since the function will process the next item on the stack as the missing arguments.\n\nThis might lead to an information leak if a sensitive value from the stack is printed. It might cause a crash if a value on the stack is interpreted as a pointer and leads to accessing unmapped memory. Finally, it may lead to a follow-on vulnerability if an attacker can use this problem to cause the output string to be too long or have unexpected contents.\n\n\n## Recommendation\nReview the format and arguments expected by the highlighted function calls. Update either the format or the arguments so that the expected number of arguments are passed to the function.\n\n\n## Example\n\n```cpp\nint main() {\n  printf(\"%d, %s\\n\", 42); // Will crash or print garbage\n  return 0;\n}\n\n```\n\n## References\n* CERT C Coding Standard: [FIO47-C. Use valid format strings](https://wiki.sei.cmu.edu/confluence/display/c/FIO47-C.+Use+valid+format+strings).\n* Microsoft C Runtime Library Reference: [printf, wprintf](https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/printf-printf-l-wprintf-wprintf-l).\n* Common Weakness Enumeration: [CWE-234](https://cwe.mitre.org/data/definitions/234.html).\n* Common Weakness Enumeration: [CWE-685](https://cwe.mitre.org/data/definitions/685.html).\n","markdown":"# Too few arguments to formatting function\nEach call to the `printf` function, or a related function, should include the number of arguments defined by the format. Passing the function more arguments than required is harmless (although it may be indicative of other defects). However, passing the function fewer arguments than are defined by the format can be a security vulnerability since the function will process the next item on the stack as the missing arguments.\n\nThis might lead to an information leak if a sensitive value from the stack is printed. It might cause a crash if a value on the stack is interpreted as a pointer and leads to accessing unmapped memory. Finally, it may lead to a follow-on vulnerability if an attacker can use this problem to cause the output string to be too long or have unexpected contents.\n\n\n## Recommendation\nReview the format and arguments expected by the highlighted function calls. Update either the format or the arguments so that the expected number of arguments are passed to the function.\n\n\n## Example\n\n```cpp\nint main() {\n  printf(\"%d, %s\\n\", 42); // Will crash or print garbage\n  return 0;\n}\n\n```\n\n## References\n* CERT C Coding Standard: [FIO47-C. Use valid format strings](https://wiki.sei.cmu.edu/confluence/display/c/FIO47-C.+Use+valid+format+strings).\n* Microsoft C Runtime Library Reference: [printf, wprintf](https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/printf-printf-l-wprintf-wprintf-l).\n* Common Weakness Enumeration: [CWE-234](https://cwe.mitre.org/data/definitions/234.html).\n* Common Weakness Enumeration: [CWE-685](https://cwe.mitre.org/data/definitions/685.html).\n"},"properties":{"tags":["reliability","correctness","security","external/cwe/cwe-234","external/cwe/cwe-685"],"description":"Calling a printf-like function with too few arguments can be\n              a source of security issues.","id":"cpp/wrong-number-format-arguments","kind":"problem","name":"Too few arguments to formatting function","precision":"high","problem.severity":"error","security-severity":"5.0"}},{"id":"cpp/pointer-overflow-check","name":"cpp/pointer-overflow-check","shortDescription":{"text":"Pointer overflow check"},"fullDescription":{"text":"Adding a value to a pointer to check if it overflows relies on undefined behavior and may lead to memory corruption."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Pointer overflow check\nWhen checking for integer overflow, you may often write tests like `p + i < p`. This works fine if `p` and `i` are unsigned integers, since any overflow in the addition will cause the value to simply \"wrap around.\" However, using this pattern when `p` is a pointer is problematic because pointer overflow has undefined behavior according to the C and C++ standards. If the addition overflows and has an undefined result, the comparison will likewise be undefined; it may produce an unintended result, or may be deleted entirely by an optimizing compiler.\n\n\n## Recommendation\nTo check whether an index `i` is less than the length of an array, simply compare these two numbers as unsigned integers: `i < ARRAY_LENGTH`. If the length of the array is defined as the difference between two pointers `ptr` and `p_end`, write `i < p_end - ptr`. If `i` is signed, cast it to unsigned in order to guard against negative `i`. For example, write `(size_t)i < p_end - ptr`.\n\n\n## Example\nAn invalid check for pointer overflow is most often seen as part of checking whether a number `a` is too large by checking first if adding the number to `ptr` goes past the end of an allocation and then checking if adding it to `ptr` creates a pointer so large that it overflows and wraps around.\n\n\n```cpp\nbool not_in_range(T *ptr, T *ptr_end, size_t i) {\n    return ptr + i >= ptr_end || ptr + i < ptr; // BAD\n}\n\n```\nIn both of these checks, the operations are performed in the wrong order. First, an expression that may cause undefined behavior is evaluated (`ptr + i`), and then the result is checked for being in range. But once undefined behavior has happened in the pointer addition, it cannot be recovered from: it's too late to perform the range check after a possible pointer overflow.\n\nWhile it's not the subject of this query, the expression `ptr + i < ptr_end` is also an invalid range check. It's undefined behavior in C/C++ to create a pointer that points more than one past the end of an allocation.\n\nThe next example shows how to portably check whether an unsigned number is outside the range of an allocation between `ptr` and `ptr_end`.\n\n\n```cpp\nbool not_in_range(T *ptr, T *ptr_end, size_t i) {\n    return i >= ptr_end - ptr; // GOOD\n}\n```\n\n## References\n* Embedded in Academia: [Pointer Overflow Checking](https://blog.regehr.org/archives/1395).\n* LWN: [GCC and pointer overflows](https://lwn.net/Articles/278137/).\n* Common Weakness Enumeration: [CWE-758](https://cwe.mitre.org/data/definitions/758.html).\n","markdown":"# Pointer overflow check\nWhen checking for integer overflow, you may often write tests like `p + i < p`. This works fine if `p` and `i` are unsigned integers, since any overflow in the addition will cause the value to simply \"wrap around.\" However, using this pattern when `p` is a pointer is problematic because pointer overflow has undefined behavior according to the C and C++ standards. If the addition overflows and has an undefined result, the comparison will likewise be undefined; it may produce an unintended result, or may be deleted entirely by an optimizing compiler.\n\n\n## Recommendation\nTo check whether an index `i` is less than the length of an array, simply compare these two numbers as unsigned integers: `i < ARRAY_LENGTH`. If the length of the array is defined as the difference between two pointers `ptr` and `p_end`, write `i < p_end - ptr`. If `i` is signed, cast it to unsigned in order to guard against negative `i`. For example, write `(size_t)i < p_end - ptr`.\n\n\n## Example\nAn invalid check for pointer overflow is most often seen as part of checking whether a number `a` is too large by checking first if adding the number to `ptr` goes past the end of an allocation and then checking if adding it to `ptr` creates a pointer so large that it overflows and wraps around.\n\n\n```cpp\nbool not_in_range(T *ptr, T *ptr_end, size_t i) {\n    return ptr + i >= ptr_end || ptr + i < ptr; // BAD\n}\n\n```\nIn both of these checks, the operations are performed in the wrong order. First, an expression that may cause undefined behavior is evaluated (`ptr + i`), and then the result is checked for being in range. But once undefined behavior has happened in the pointer addition, it cannot be recovered from: it's too late to perform the range check after a possible pointer overflow.\n\nWhile it's not the subject of this query, the expression `ptr + i < ptr_end` is also an invalid range check. It's undefined behavior in C/C++ to create a pointer that points more than one past the end of an allocation.\n\nThe next example shows how to portably check whether an unsigned number is outside the range of an allocation between `ptr` and `ptr_end`.\n\n\n```cpp\nbool not_in_range(T *ptr, T *ptr_end, size_t i) {\n    return i >= ptr_end - ptr; // GOOD\n}\n```\n\n## References\n* Embedded in Academia: [Pointer Overflow Checking](https://blog.regehr.org/archives/1395).\n* LWN: [GCC and pointer overflows](https://lwn.net/Articles/278137/).\n* Common Weakness Enumeration: [CWE-758](https://cwe.mitre.org/data/definitions/758.html).\n"},"properties":{"tags":["reliability","security","external/cwe/cwe-758"],"description":"Adding a value to a pointer to check if it overflows relies\n              on undefined behavior and may lead to memory corruption.","id":"cpp/pointer-overflow-check","kind":"problem","name":"Pointer overflow check","precision":"high","problem.severity":"error","security-severity":"2.1"}},{"id":"cpp/unsafe-strncat","name":"cpp/unsafe-strncat","shortDescription":{"text":"Potentially unsafe call to strncat"},"fullDescription":{"text":"Calling 'strncat' with an incorrect size argument may result in a buffer overflow."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Potentially unsafe call to strncat\nThe standard library function `strncat` appends a source string to a target string. The third argument defines the maximum number of characters to append and should be less than or equal to the remaining space in the destination buffer.\n\nCalls of the form `strncat(dest, src, strlen(dest))` or `strncat(dest, src, sizeof(dest))` set the third argument to the entire size of the destination buffer. Executing a call of this type may cause a buffer overflow unless the buffer is known to be empty.\n\nSimilarly, calls of the form `strncat(dest, src, sizeof (dest) - strlen (dest))` allow one byte to be written outside the `dest` buffer.\n\nBuffer overflows can lead to anything from a segmentation fault to a security vulnerability.\n\n\n## Recommendation\nCheck the highlighted function calls carefully to ensure that no buffer overflow is possible. For a more robust solution, consider updating the function call to include the remaining space in the destination buffer.\n\n\n## Example\n\n```cpp\nstrncat(dest, src, strlen(dest)); //wrong: should use remaining size of dest\n\nstrncat(dest, src, sizeof(dest)); //wrong: should use remaining size of dest. \n                                  //Also fails if dest is a pointer and not an array.\n \nstrncat(dest, source, sizeof(dest) - strlen(dest)); // wrong: writes a zero byte past the `dest` buffer.\n\nstrncat(dest, source, sizeof(dest) - strlen(dest) - 1); // correct: reserves space for the zero byte.\n\n```\n\n## References\n* cplusplus.com: [strncat](http://www.cplusplus.com/reference/clibrary/cstring/strncat/), [strncpy](http://www.cplusplus.com/reference/clibrary/cstring/strncpy/).\n* I. Gerg, *An Overview and Example of the Buffer-Overflow Exploit*. IANewsletter vol 7 no 4, 2005.\n* M. Donaldson, *Inside the Buffer Overflow Attack: Mechanism, Method &amp; Prevention*. SANS Institute InfoSec Reading Room, 2002.\n* CERT C Coding Standard: [STR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator](https://wiki.sei.cmu.edu/confluence/display/c/STR31-C.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator).\n* Common Weakness Enumeration: [CWE-788](https://cwe.mitre.org/data/definitions/788.html).\n* Common Weakness Enumeration: [CWE-676](https://cwe.mitre.org/data/definitions/676.html).\n* Common Weakness Enumeration: [CWE-119](https://cwe.mitre.org/data/definitions/119.html).\n* Common Weakness Enumeration: [CWE-251](https://cwe.mitre.org/data/definitions/251.html).\n","markdown":"# Potentially unsafe call to strncat\nThe standard library function `strncat` appends a source string to a target string. The third argument defines the maximum number of characters to append and should be less than or equal to the remaining space in the destination buffer.\n\nCalls of the form `strncat(dest, src, strlen(dest))` or `strncat(dest, src, sizeof(dest))` set the third argument to the entire size of the destination buffer. Executing a call of this type may cause a buffer overflow unless the buffer is known to be empty.\n\nSimilarly, calls of the form `strncat(dest, src, sizeof (dest) - strlen (dest))` allow one byte to be written outside the `dest` buffer.\n\nBuffer overflows can lead to anything from a segmentation fault to a security vulnerability.\n\n\n## Recommendation\nCheck the highlighted function calls carefully to ensure that no buffer overflow is possible. For a more robust solution, consider updating the function call to include the remaining space in the destination buffer.\n\n\n## Example\n\n```cpp\nstrncat(dest, src, strlen(dest)); //wrong: should use remaining size of dest\n\nstrncat(dest, src, sizeof(dest)); //wrong: should use remaining size of dest. \n                                  //Also fails if dest is a pointer and not an array.\n \nstrncat(dest, source, sizeof(dest) - strlen(dest)); // wrong: writes a zero byte past the `dest` buffer.\n\nstrncat(dest, source, sizeof(dest) - strlen(dest) - 1); // correct: reserves space for the zero byte.\n\n```\n\n## References\n* cplusplus.com: [strncat](http://www.cplusplus.com/reference/clibrary/cstring/strncat/), [strncpy](http://www.cplusplus.com/reference/clibrary/cstring/strncpy/).\n* I. Gerg, *An Overview and Example of the Buffer-Overflow Exploit*. IANewsletter vol 7 no 4, 2005.\n* M. Donaldson, *Inside the Buffer Overflow Attack: Mechanism, Method &amp; Prevention*. SANS Institute InfoSec Reading Room, 2002.\n* CERT C Coding Standard: [STR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator](https://wiki.sei.cmu.edu/confluence/display/c/STR31-C.+Guarantee+that+storage+for+strings+has+sufficient+space+for+character+data+and+the+null+terminator).\n* Common Weakness Enumeration: [CWE-788](https://cwe.mitre.org/data/definitions/788.html).\n* Common Weakness Enumeration: [CWE-676](https://cwe.mitre.org/data/definitions/676.html).\n* Common Weakness Enumeration: [CWE-119](https://cwe.mitre.org/data/definitions/119.html).\n* Common Weakness Enumeration: [CWE-251](https://cwe.mitre.org/data/definitions/251.html).\n"},"properties":{"tags":["reliability","correctness","security","external/cwe/cwe-788","external/cwe/cwe-676","external/cwe/cwe-119","external/cwe/cwe-251"],"description":"Calling 'strncat' with an incorrect size argument may result in a buffer overflow.","id":"cpp/unsafe-strncat","kind":"problem","name":"Potentially unsafe call to strncat","precision":"high","problem.severity":"warning","security-severity":"9.3"}},{"id":"cpp/using-expired-stack-address","name":"cpp/using-expired-stack-address","shortDescription":{"text":"Use of expired stack-address"},"fullDescription":{"text":"Accessing the stack-allocated memory of a function after it has returned can lead to memory corruption."},"defaultConfiguration":{"enabled":true,"level":"error"},"help":{"text":"# Use of expired stack-address\nThis rule finds uses of pointers that likely point to local variables in expired stack frames. A pointer to a local variable is only valid until the function returns, after which it becomes a dangling pointer.\n\n\n## Recommendation\n1. If it is necessary to take the address of a local variable, then make sure that the address is only stored in memory that does not outlive the local variable. For example, it is safe to store the address in another local variable. Similarly, it is also safe to pass the address of a local variable to another function provided that the other function only uses it locally and does not store it in non-local memory.\n1. If it is necessary to store an address which will outlive the current function scope, then it should be allocated on the heap. Care should be taken to make sure that the memory is deallocated when it is no longer needed, particularly when using low-level memory management routines such as `malloc`/`free` or `new`/`delete`. Modern C++ applications often use smart pointers, such as `std::shared_ptr`, to reduce the chance of a memory leak.\n\n## Example\n\n```cpp\nstatic const int* xptr;\n\nvoid localAddressEscapes() {\n  int x = 0;\n  xptr = &x;\n}\n\nvoid example1() {\n  localAddressEscapes();\n  const int* x = xptr; // BAD: This pointer points to expired stack allocated memory.\n}\n\nvoid localAddressDoesNotEscape() {\n  int x = 0;\n  xptr = &x;\n  // ...\n  // use `xptr`\n  // ...\n  xptr = nullptr;\n}\n\nvoid example2() {\n  localAddressDoesNotEscape();\n  const int* x = xptr; // GOOD: This pointer does not point to expired memory.\n}\n\n```\n\n## References\n* Wikipedia: [Dangling pointer](https://en.wikipedia.org/wiki/Dangling_pointer).\n* Common Weakness Enumeration: [CWE-825](https://cwe.mitre.org/data/definitions/825.html).\n","markdown":"# Use of expired stack-address\nThis rule finds uses of pointers that likely point to local variables in expired stack frames. A pointer to a local variable is only valid until the function returns, after which it becomes a dangling pointer.\n\n\n## Recommendation\n1. If it is necessary to take the address of a local variable, then make sure that the address is only stored in memory that does not outlive the local variable. For example, it is safe to store the address in another local variable. Similarly, it is also safe to pass the address of a local variable to another function provided that the other function only uses it locally and does not store it in non-local memory.\n1. If it is necessary to store an address which will outlive the current function scope, then it should be allocated on the heap. Care should be taken to make sure that the memory is deallocated when it is no longer needed, particularly when using low-level memory management routines such as `malloc`/`free` or `new`/`delete`. Modern C++ applications often use smart pointers, such as `std::shared_ptr`, to reduce the chance of a memory leak.\n\n## Example\n\n```cpp\nstatic const int* xptr;\n\nvoid localAddressEscapes() {\n  int x = 0;\n  xptr = &x;\n}\n\nvoid example1() {\n  localAddressEscapes();\n  const int* x = xptr; // BAD: This pointer points to expired stack allocated memory.\n}\n\nvoid localAddressDoesNotEscape() {\n  int x = 0;\n  xptr = &x;\n  // ...\n  // use `xptr`\n  // ...\n  xptr = nullptr;\n}\n\nvoid example2() {\n  localAddressDoesNotEscape();\n  const int* x = xptr; // GOOD: This pointer does not point to expired memory.\n}\n\n```\n\n## References\n* Wikipedia: [Dangling pointer](https://en.wikipedia.org/wiki/Dangling_pointer).\n* Common Weakness Enumeration: [CWE-825](https://cwe.mitre.org/data/definitions/825.html).\n"},"properties":{"tags":["reliability","security","external/cwe/cwe-825"],"description":"Accessing the stack-allocated memory of a function\n              after it has returned can lead to memory corruption.","id":"cpp/using-expired-stack-address","kind":"path-problem","name":"Use of expired stack-address","precision":"high","problem.severity":"error","security-severity":"9.3"}},{"id":"cpp/return-stack-allocated-memory","name":"cpp/return-stack-allocated-memory","shortDescription":{"text":"Returning stack-allocated memory"},"fullDescription":{"text":"A function returns a pointer to a stack-allocated region of memory. This memory is deallocated at the end of the function, which may lead the caller to dereference a dangling pointer."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Returning stack-allocated memory\nThis rule finds return statements that return pointers to an object allocated on the stack. The lifetime of a stack allocated memory location only lasts until the function returns, and the contents of that memory become undefined after that. Clearly, using a pointer to stack memory after the function has already returned will have undefined results.\n\n\n## Recommendation\nUse the functions of the `malloc` family, or `new`, to dynamically allocate memory on the heap for data that is used across function calls.\n\n\n## Example\nThe following example allocates an object on the stack and returns a pointer to it. This is incorrect because the object is deallocated when the function returns, and the pointer becomes invalid.\n\n\n```cpp\nRecord *mkRecord(int value) {\n\tRecord myRecord(value);\n\n\treturn &myRecord; // BAD: returns a pointer to `myRecord`, which is a stack-allocated object.\n}\n\n```\nTo fix this, allocate the object on the heap using `new` and return a pointer to the heap-allocated object.\n\n\n```cpp\nRecord *mkRecord(int value) {\n\tRecord *myRecord = new Record(value);\n\n\treturn myRecord; // GOOD: returns a pointer to a `myRecord`, which is a heap-allocated object.\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-825](https://cwe.mitre.org/data/definitions/825.html).\n","markdown":"# Returning stack-allocated memory\nThis rule finds return statements that return pointers to an object allocated on the stack. The lifetime of a stack allocated memory location only lasts until the function returns, and the contents of that memory become undefined after that. Clearly, using a pointer to stack memory after the function has already returned will have undefined results.\n\n\n## Recommendation\nUse the functions of the `malloc` family, or `new`, to dynamically allocate memory on the heap for data that is used across function calls.\n\n\n## Example\nThe following example allocates an object on the stack and returns a pointer to it. This is incorrect because the object is deallocated when the function returns, and the pointer becomes invalid.\n\n\n```cpp\nRecord *mkRecord(int value) {\n\tRecord myRecord(value);\n\n\treturn &myRecord; // BAD: returns a pointer to `myRecord`, which is a stack-allocated object.\n}\n\n```\nTo fix this, allocate the object on the heap using `new` and return a pointer to the heap-allocated object.\n\n\n```cpp\nRecord *mkRecord(int value) {\n\tRecord *myRecord = new Record(value);\n\n\treturn myRecord; // GOOD: returns a pointer to a `myRecord`, which is a heap-allocated object.\n}\n\n```\n\n## References\n* Common Weakness Enumeration: [CWE-825](https://cwe.mitre.org/data/definitions/825.html).\n"},"properties":{"tags":["reliability","security","external/cwe/cwe-825"],"description":"A function returns a pointer to a stack-allocated region of\n              memory. This memory is deallocated at the end of the function,\n              which may lead the caller to dereference a dangling pointer.","id":"cpp/return-stack-allocated-memory","kind":"path-problem","name":"Returning stack-allocated memory","precision":"high","problem.severity":"warning","security-severity":"9.3"}},{"id":"cpp/alloca-in-loop","name":"cpp/alloca-in-loop","shortDescription":{"text":"Call to alloca in a loop"},"fullDescription":{"text":"Using alloca in a loop can lead to a stack overflow"},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Call to alloca in a loop\nThe `alloca` macro allocates memory by expanding the current stack frame. Invoking `alloca` within a loop may lead to a stack overflow because the memory is not released until the function returns.\n\n\n## Recommendation\nConsider invoking `alloca` once outside the loop, or using `malloc` or `new` to allocate memory on the heap if the allocation must be done inside the loop.\n\n\n## Example\nThe variable `path` is allocated inside a loop with `alloca`. Consequently, storage for all copies of the path is present in the stack frame until the end of the function.\n\n\n```cpp\nchar *dir_path;\nchar **dir_entries;\nint count;\n\nfor (int i = 0; i < count; i++) {\n  char *path = (char*)alloca(strlen(dir_path) + strlen(dir_entry[i]) + 2);\n  // use path\n}\n\n```\nIn the revised example, `path` is allocated with `malloc` and freed at the end of the loop.\n\n\n```cpp\nchar *dir_path;\nchar **dir_entries;\nint count;\n\nfor (int i = 0; i < count; i++) {\n  char *path = (char*)malloc(strlen(dir_path) + strlen(dir_entry[i]) + 2);\n  // use path\n  free(path);\n}\n\n```\n\n## References\n* Linux Programmer's Manual: [ALLOCA(3)](http://man7.org/linux/man-pages/man3/alloca.3.html).\n* Common Weakness Enumeration: [CWE-770](https://cwe.mitre.org/data/definitions/770.html).\n","markdown":"# Call to alloca in a loop\nThe `alloca` macro allocates memory by expanding the current stack frame. Invoking `alloca` within a loop may lead to a stack overflow because the memory is not released until the function returns.\n\n\n## Recommendation\nConsider invoking `alloca` once outside the loop, or using `malloc` or `new` to allocate memory on the heap if the allocation must be done inside the loop.\n\n\n## Example\nThe variable `path` is allocated inside a loop with `alloca`. Consequently, storage for all copies of the path is present in the stack frame until the end of the function.\n\n\n```cpp\nchar *dir_path;\nchar **dir_entries;\nint count;\n\nfor (int i = 0; i < count; i++) {\n  char *path = (char*)alloca(strlen(dir_path) + strlen(dir_entry[i]) + 2);\n  // use path\n}\n\n```\nIn the revised example, `path` is allocated with `malloc` and freed at the end of the loop.\n\n\n```cpp\nchar *dir_path;\nchar **dir_entries;\nint count;\n\nfor (int i = 0; i < count; i++) {\n  char *path = (char*)malloc(strlen(dir_path) + strlen(dir_entry[i]) + 2);\n  // use path\n  free(path);\n}\n\n```\n\n## References\n* Linux Programmer's Manual: [ALLOCA(3)](http://man7.org/linux/man-pages/man3/alloca.3.html).\n* Common Weakness Enumeration: [CWE-770](https://cwe.mitre.org/data/definitions/770.html).\n"},"properties":{"tags":["reliability","correctness","security","external/cwe/cwe-770"],"description":"Using alloca in a loop can lead to a stack overflow","id":"cpp/alloca-in-loop","kind":"problem","name":"Call to alloca in a loop","precision":"high","problem.severity":"warning","security-severity":"7.5"}},{"id":"cpp/static-buffer-overflow","name":"cpp/static-buffer-overflow","shortDescription":{"text":"Static array access may cause overflow"},"fullDescription":{"text":"Exceeding the size of a static array during write or access operations may result in a buffer overflow."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Static array access may cause overflow\nWhen you use static arrays you must ensure that you do not exceed the size of the array during write and access operations. If an operation attempts to write to or access an element that is outside the range of the array then this results in a buffer overflow. Buffer overflows can lead to anything from a segmentation fault to a security vulnerability.\n\n\n## Recommendation\nCheck the offsets and sizes used in the highlighted operations to ensure that a buffer overflow will not occur.\n\n\n## Example\n\n```cpp\n#define SIZE 30\n\nint f(char * s) {\n\tchar buf[20]; //buf not set to use SIZE macro\n\n\tstrncpy(buf, s, SIZE); //wrong: copy may exceed size of buf\n\n\tfor (int i = 0; i < SIZE; i++) { //wrong: upper limit that is higher than array size\n\t\tcout << array[i];\n\t}\n}\n\n```\n\n## References\n* I. Gerg. *An Overview and Example of the Buffer-Overflow Exploit*. IANewsletter vol 7 no 4. 2005.\n* M. Donaldson. *Inside the Buffer Overflow Attack: Mechanism, Method &amp; Prevention*. SANS Institute InfoSec Reading Room. 2002.\n* Common Weakness Enumeration: [CWE-119](https://cwe.mitre.org/data/definitions/119.html).\n* Common Weakness Enumeration: [CWE-131](https://cwe.mitre.org/data/definitions/131.html).\n","markdown":"# Static array access may cause overflow\nWhen you use static arrays you must ensure that you do not exceed the size of the array during write and access operations. If an operation attempts to write to or access an element that is outside the range of the array then this results in a buffer overflow. Buffer overflows can lead to anything from a segmentation fault to a security vulnerability.\n\n\n## Recommendation\nCheck the offsets and sizes used in the highlighted operations to ensure that a buffer overflow will not occur.\n\n\n## Example\n\n```cpp\n#define SIZE 30\n\nint f(char * s) {\n\tchar buf[20]; //buf not set to use SIZE macro\n\n\tstrncpy(buf, s, SIZE); //wrong: copy may exceed size of buf\n\n\tfor (int i = 0; i < SIZE; i++) { //wrong: upper limit that is higher than array size\n\t\tcout << array[i];\n\t}\n}\n\n```\n\n## References\n* I. Gerg. *An Overview and Example of the Buffer-Overflow Exploit*. IANewsletter vol 7 no 4. 2005.\n* M. Donaldson. *Inside the Buffer Overflow Attack: Mechanism, Method &amp; Prevention*. SANS Institute InfoSec Reading Room. 2002.\n* Common Weakness Enumeration: [CWE-119](https://cwe.mitre.org/data/definitions/119.html).\n* Common Weakness Enumeration: [CWE-131](https://cwe.mitre.org/data/definitions/131.html).\n"},"properties":{"tags":["reliability","security","external/cwe/cwe-119","external/cwe/cwe-131"],"description":"Exceeding the size of a static array during write or access operations\n              may result in a buffer overflow.","id":"cpp/static-buffer-overflow","kind":"problem","name":"Static array access may cause overflow","precision":"high","problem.severity":"warning","security-severity":"9.3"}},{"id":"cpp/incorrectly-checked-scanf","name":"cpp/incorrectly-checked-scanf","shortDescription":{"text":"Incorrect return-value check for a 'scanf'-like function"},"fullDescription":{"text":"Failing to account for EOF in a call to a scanf-like function can lead to undefined behavior."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Incorrect return-value check for a 'scanf'-like function\nThis query finds calls of `scanf`-like functions with improper return-value checking. Specifically, it flags uses of `scanf` where the return value is only checked against zero.\n\nFunctions in the `scanf` family return either `EOF` (a negative value) in case of IO failure, or the number of items successfully read from the input. Consequently, a simple check that the return value is nonzero is not enough.\n\n\n## Recommendation\nEnsure that all uses of `scanf` check the return value against the expected number of arguments rather than just against zero.\n\n\n## Example\nThe following examples show different ways of guarding a `scanf` output. In the BAD examples, the results are only checked against zero. In the GOOD examples, the results are checked against the expected number of matches instead.\n\n\n```cpp\n{\n  int i, j;\n\n  // BAD: The result is only checked against zero\n  if (scanf(\"%d %d\", &i, &j)) { \n      use(i);\n      use(j);\n  }\n\n  // BAD: The result is only checked against zero\n  if (scanf(\"%d %d\", &i, &j) == 0) { \n    i = 0;\n    j = 0;\n  }\n  use(i);\n  use(j);\n\n  if (scanf(\"%d %d\", &i, &j) == 2) { \n      // GOOD: the result is checked against 2\n  }\n\n  // GOOD: the result is compared directly\n  int r = scanf(\"%d %d\", &i, &j);\n  if (r < 2) {\n    return;\n  }\n  if (r == 1) { \n    j = 0;\n  }\n}\n\n```\n\n## References\n* SEI CERT C++ Coding Standard: [ERR62-CPP. Detect errors when converting a string to a number](https://wiki.sei.cmu.edu/confluence/display/cplusplus/ERR62-CPP.+Detect+errors+when+converting+a+string+to+a+number).\n* SEI CERT C Coding Standard: [ERR33-C. Detect and handle standard library errors](https://wiki.sei.cmu.edu/confluence/display/c/ERR33-C.+Detect+and+handle+standard+library+errors).\n* cppreference.com: [scanf, fscanf, sscanf, scanf_s, fscanf_s, sscanf_s](https://en.cppreference.com/w/c/io/fscanf).\n* Common Weakness Enumeration: [CWE-253](https://cwe.mitre.org/data/definitions/253.html).\n","markdown":"# Incorrect return-value check for a 'scanf'-like function\nThis query finds calls of `scanf`-like functions with improper return-value checking. Specifically, it flags uses of `scanf` where the return value is only checked against zero.\n\nFunctions in the `scanf` family return either `EOF` (a negative value) in case of IO failure, or the number of items successfully read from the input. Consequently, a simple check that the return value is nonzero is not enough.\n\n\n## Recommendation\nEnsure that all uses of `scanf` check the return value against the expected number of arguments rather than just against zero.\n\n\n## Example\nThe following examples show different ways of guarding a `scanf` output. In the BAD examples, the results are only checked against zero. In the GOOD examples, the results are checked against the expected number of matches instead.\n\n\n```cpp\n{\n  int i, j;\n\n  // BAD: The result is only checked against zero\n  if (scanf(\"%d %d\", &i, &j)) { \n      use(i);\n      use(j);\n  }\n\n  // BAD: The result is only checked against zero\n  if (scanf(\"%d %d\", &i, &j) == 0) { \n    i = 0;\n    j = 0;\n  }\n  use(i);\n  use(j);\n\n  if (scanf(\"%d %d\", &i, &j) == 2) { \n      // GOOD: the result is checked against 2\n  }\n\n  // GOOD: the result is compared directly\n  int r = scanf(\"%d %d\", &i, &j);\n  if (r < 2) {\n    return;\n  }\n  if (r == 1) { \n    j = 0;\n  }\n}\n\n```\n\n## References\n* SEI CERT C++ Coding Standard: [ERR62-CPP. Detect errors when converting a string to a number](https://wiki.sei.cmu.edu/confluence/display/cplusplus/ERR62-CPP.+Detect+errors+when+converting+a+string+to+a+number).\n* SEI CERT C Coding Standard: [ERR33-C. Detect and handle standard library errors](https://wiki.sei.cmu.edu/confluence/display/c/ERR33-C.+Detect+and+handle+standard+library+errors).\n* cppreference.com: [scanf, fscanf, sscanf, scanf_s, fscanf_s, sscanf_s](https://en.cppreference.com/w/c/io/fscanf).\n* Common Weakness Enumeration: [CWE-253](https://cwe.mitre.org/data/definitions/253.html).\n"},"properties":{"tags":["security","correctness","external/cwe/cwe-253"],"description":"Failing to account for EOF in a call to a scanf-like function can lead to\n             undefined behavior.","id":"cpp/incorrectly-checked-scanf","kind":"problem","name":"Incorrect return-value check for a 'scanf'-like function","precision":"high","problem.severity":"warning","security-severity":"7.5"}},{"id":"cpp/new-free-mismatch","name":"cpp/new-free-mismatch","shortDescription":{"text":"Mismatching new/free or malloc/delete"},"fullDescription":{"text":"An object that was allocated with 'malloc' or 'new' is being freed using a mismatching 'free' or 'delete'."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Mismatching new/free or malloc/delete\nThis rule finds `delete` expressions whose argument is a pointer that points to memory allocated using the `malloc` function, and calls to `free` whose argument is a pointer that points to memory allocated using the `new` operator. Behavior in such cases is undefined and should be avoided.\n\n\n## Recommendation\nUse the `delete` operator when freeing memory allocated with `new`, and the `free` function when freeing memory allocated with `malloc`.\n\n\n## Example\n\n```cpp\nRecord *ptr = new Record(...);\n\n...\n\nfree(ptr); // BAD: ptr was created using 'new', but is being freed using 'free'\n\n```\n\n## References\n* isocpp.org 'Standard C++', \"[Can I free() pointers allocated with new? Can I delete pointers allocated with malloc()?](https://isocpp.org/wiki/faq/freestore-mgmt#mixing-malloc-and-delete)\"\n* Wikipedia, \"[Relation to malloc and free](https://en.wikipedia.org/wiki/New_and_delete_(C%2B%2B)#Relation_to_malloc_and_free)\" in *new and delete (C++)*.\n* Common Weakness Enumeration: [CWE-401](https://cwe.mitre.org/data/definitions/401.html).\n","markdown":"# Mismatching new/free or malloc/delete\nThis rule finds `delete` expressions whose argument is a pointer that points to memory allocated using the `malloc` function, and calls to `free` whose argument is a pointer that points to memory allocated using the `new` operator. Behavior in such cases is undefined and should be avoided.\n\n\n## Recommendation\nUse the `delete` operator when freeing memory allocated with `new`, and the `free` function when freeing memory allocated with `malloc`.\n\n\n## Example\n\n```cpp\nRecord *ptr = new Record(...);\n\n...\n\nfree(ptr); // BAD: ptr was created using 'new', but is being freed using 'free'\n\n```\n\n## References\n* isocpp.org 'Standard C++', \"[Can I free() pointers allocated with new? Can I delete pointers allocated with malloc()?](https://isocpp.org/wiki/faq/freestore-mgmt#mixing-malloc-and-delete)\"\n* Wikipedia, \"[Relation to malloc and free](https://en.wikipedia.org/wiki/New_and_delete_(C%2B%2B)#Relation_to_malloc_and_free)\" in *new and delete (C++)*.\n* Common Weakness Enumeration: [CWE-401](https://cwe.mitre.org/data/definitions/401.html).\n"},"properties":{"tags":["reliability","security","external/cwe/cwe-401"],"description":"An object that was allocated with 'malloc' or 'new' is being freed using a mismatching 'free' or 'delete'.","id":"cpp/new-free-mismatch","kind":"problem","name":"Mismatching new/free or malloc/delete","precision":"high","problem.severity":"warning","security-severity":"7.5"}},{"id":"cpp/double-free","name":"cpp/double-free","shortDescription":{"text":"Potential double free"},"fullDescription":{"text":"Freeing a resource more than once can lead to undefined behavior and cause memory corruption."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Potential double free\nDeallocating memory more than once can lead to a double-free vulnerability. This can be exploited to corrupt the allocator's internal data structures, which can lead to denial-of-service attacks by crashing the program, or security vulnerabilities, by allowing an attacker to overwrite arbitrary memory locations.\n\n\n## Recommendation\nEnsure that all execution paths deallocate the allocated memory at most once. In complex cases it may help to reassign a pointer to a null value after deallocating it. This will prevent double-free vulnerabilities since most deallocation functions will perform a null-pointer check before attempting to deallocate memory.\n\n\n## Example\nIn the following example, `buff` is allocated and then freed twice:\n\n\n```cpp\nint* f() {\n\tint *buff = malloc(SIZE*sizeof(int));\n\tdo_stuff(buff);\n\tfree(buff);\n\tint *new_buffer = malloc(SIZE*sizeof(int));\n\tfree(buff); // BAD: If new_buffer is assigned the same address as buff,\n              // the memory allocator will free the new buffer memory region,\n              // leading to use-after-free problems and memory corruption.\n\treturn new_buffer;\n}\n\n```\nReviewing the code above, the issue can be fixed by simply deleting the additional call to `free(buff)`.\n\n\n```cpp\nint* f() {\n\tint *buff = malloc(SIZE*sizeof(int));\n\tdo_stuff(buff);\n\tfree(buff); // GOOD: buff is only freed once.\n\tint *new_buffer = malloc(SIZE*sizeof(int));\n\treturn new_buffer;\n}\n\n```\nIn the next example, `task` may be deleted twice, if an exception occurs inside the `try` block after the first `delete`:\n\n\n```cpp\nvoid g() {\n\tMyTask *task = nullptr;\n\n\ttry\n\t{\n\t\ttask = new MyTask;\n\n\t\t...\n\n\t\tdelete task;\n\n\t\t...\n\t} catch (...) {\n\t\tdelete task; // BAD: potential double-free\n\t}\n}\n\n```\nThe problem can be solved by assigning a null value to the pointer after the first `delete`, as calling `delete` a second time on the null pointer is harmless.\n\n\n```cpp\nvoid g() {\n\tMyTask *task = nullptr;\n\n\ttry\n\t{\n\t\ttask = new MyTask;\n\n\t\t...\n\n\t\tdelete task;\n\t\ttask = nullptr;\n\n\t\t...\n\t} catch (...) {\n\t\tdelete task; // GOOD: harmless if task is NULL\n\t}\n}\n\n```\n\n## References\n* OWASP: [Doubly freeing memory](https://owasp.org/www-community/vulnerabilities/Doubly_freeing_memory).\n* Common Weakness Enumeration: [CWE-415](https://cwe.mitre.org/data/definitions/415.html).\n","markdown":"# Potential double free\nDeallocating memory more than once can lead to a double-free vulnerability. This can be exploited to corrupt the allocator's internal data structures, which can lead to denial-of-service attacks by crashing the program, or security vulnerabilities, by allowing an attacker to overwrite arbitrary memory locations.\n\n\n## Recommendation\nEnsure that all execution paths deallocate the allocated memory at most once. In complex cases it may help to reassign a pointer to a null value after deallocating it. This will prevent double-free vulnerabilities since most deallocation functions will perform a null-pointer check before attempting to deallocate memory.\n\n\n## Example\nIn the following example, `buff` is allocated and then freed twice:\n\n\n```cpp\nint* f() {\n\tint *buff = malloc(SIZE*sizeof(int));\n\tdo_stuff(buff);\n\tfree(buff);\n\tint *new_buffer = malloc(SIZE*sizeof(int));\n\tfree(buff); // BAD: If new_buffer is assigned the same address as buff,\n              // the memory allocator will free the new buffer memory region,\n              // leading to use-after-free problems and memory corruption.\n\treturn new_buffer;\n}\n\n```\nReviewing the code above, the issue can be fixed by simply deleting the additional call to `free(buff)`.\n\n\n```cpp\nint* f() {\n\tint *buff = malloc(SIZE*sizeof(int));\n\tdo_stuff(buff);\n\tfree(buff); // GOOD: buff is only freed once.\n\tint *new_buffer = malloc(SIZE*sizeof(int));\n\treturn new_buffer;\n}\n\n```\nIn the next example, `task` may be deleted twice, if an exception occurs inside the `try` block after the first `delete`:\n\n\n```cpp\nvoid g() {\n\tMyTask *task = nullptr;\n\n\ttry\n\t{\n\t\ttask = new MyTask;\n\n\t\t...\n\n\t\tdelete task;\n\n\t\t...\n\t} catch (...) {\n\t\tdelete task; // BAD: potential double-free\n\t}\n}\n\n```\nThe problem can be solved by assigning a null value to the pointer after the first `delete`, as calling `delete` a second time on the null pointer is harmless.\n\n\n```cpp\nvoid g() {\n\tMyTask *task = nullptr;\n\n\ttry\n\t{\n\t\ttask = new MyTask;\n\n\t\t...\n\n\t\tdelete task;\n\t\ttask = nullptr;\n\n\t\t...\n\t} catch (...) {\n\t\tdelete task; // GOOD: harmless if task is NULL\n\t}\n}\n\n```\n\n## References\n* OWASP: [Doubly freeing memory](https://owasp.org/www-community/vulnerabilities/Doubly_freeing_memory).\n* Common Weakness Enumeration: [CWE-415](https://cwe.mitre.org/data/definitions/415.html).\n"},"properties":{"tags":["reliability","security","external/cwe/cwe-415"],"description":"Freeing a resource more than once can lead to undefined behavior and cause memory corruption.","id":"cpp/double-free","kind":"path-problem","name":"Potential double free","precision":"high","problem.severity":"warning","security-severity":"9.3"}},{"id":"cpp/use-after-free","name":"cpp/use-after-free","shortDescription":{"text":"Potential use after free"},"fullDescription":{"text":"An allocated memory block is used after it has been freed. Behavior in such cases is undefined and can cause memory corruption."},"defaultConfiguration":{"enabled":true,"level":"warning"},"help":{"text":"# Potential use after free\nThis rule finds accesses through a pointer of a memory location that has already been freed (i.e. through a dangling pointer). Such memory blocks have already been released to the dynamic memory manager, and modifying them can lead to anything from a segfault to memory corruption that would cause subsequent calls to the dynamic memory manager to behave erratically, to a possible security vulnerability.\n\n> WARNING: This check is an approximation, so some results may not be actual defects in the program. It is not possible in general to compute the values of pointers without running the program with all input data.\n\n## Recommendation\nEnsure that all execution paths that access memory through a pointer never access that pointer after it is freed.\n\n\n## Example\n\n```cpp\nvoid f() {\n\tchar* buf = new char[SIZE];\n\t...\n\tif (error) {\n\t\tdelete buf; //error handling has freed the buffer\n\t}\n\t...\n\tlog_contents(buf); //but it is still used here for logging\n\t...\n}\n\n```\n\n## References\n* I. Gerg. *An Overview and Example of the Buffer-Overflow Exploit*. IANewsletter vol 7 no 4. 2005.\n* M. Donaldson. *Inside the Buffer Overflow Attack: Mechanism, Method &amp; Prevention*. SANS Institute InfoSec Reading Room. 2002.\n* Common Weakness Enumeration: [CWE-416](https://cwe.mitre.org/data/definitions/416.html).\n","markdown":"# Potential use after free\nThis rule finds accesses through a pointer of a memory location that has already been freed (i.e. through a dangling pointer). Such memory blocks have already been released to the dynamic memory manager, and modifying them can lead to anything from a segfault to memory corruption that would cause subsequent calls to the dynamic memory manager to behave erratically, to a possible security vulnerability.\n\n> WARNING: This check is an approximation, so some results may not be actual defects in the program. It is not possible in general to compute the values of pointers without running the program with all input data.\n\n## Recommendation\nEnsure that all execution paths that access memory through a pointer never access that pointer after it is freed.\n\n\n## Example\n\n```cpp\nvoid f() {\n\tchar* buf = new char[SIZE];\n\t...\n\tif (error) {\n\t\tdelete buf; //error handling has freed the buffer\n\t}\n\t...\n\tlog_contents(buf); //but it is still used here for logging\n\t...\n}\n\n```\n\n## References\n* I. Gerg. *An Overview and Example of the Buffer-Overflow Exploit*. IANewsletter vol 7 no 4. 2005.\n* M. Donaldson. *Inside the Buffer Overflow Attack: Mechanism, Method &amp; Prevention*. SANS Institute InfoSec Reading Room. 2002.\n* Common Weakness Enumeration: [CWE-416](https://cwe.mitre.org/data/definitions/416.html).\n"},"properties":{"tags":["reliability","security","external/cwe/cwe-416"],"description":"An allocated memory block is used after it has been freed. Behavior in such cases is undefined and can cause memory corruption.","id":"cpp/use-after-free","kind":"path-problem","name":"Potential use after free","precision":"high","problem.severity":"warning","security-severity":"9.3"}},{"id":"cpp/telemetry/compiler-errors","name":"cpp/telemetry/compiler-errors","shortDescription":{"text":"Compiler errors"},"fullDescription":{"text":"A count of all compiler errors, grouped by error text."},"defaultConfiguration":{"enabled":true},"properties":{"tags":["summary","telemetry"],"description":"A count of all compiler errors, grouped by error text.","id":"cpp/telemetry/compiler-errors","kind":"metric","name":"Compiler errors"}},{"id":"cpp/telemetry/database-quality","name":"cpp/telemetry/database-quality","shortDescription":{"text":"Database quality"},"fullDescription":{"text":"Metrics that indicate the quality of the database."},"defaultConfiguration":{"enabled":true},"properties":{"tags":["summary","telemetry"],"description":"Metrics that indicate the quality of the database.","id":"cpp/telemetry/database-quality","kind":"metric","name":"Database quality"}},{"id":"cpp/telemetry/succeeded-includes","name":"cpp/telemetry/succeeded-includes","shortDescription":{"text":"Successfully included header files"},"fullDescription":{"text":"A count of all succeeded includes, grouped by filename."},"defaultConfiguration":{"enabled":true},"properties":{"tags":["summary","telemetry"],"description":"A count of all succeeded includes, grouped by filename.","id":"cpp/telemetry/succeeded-includes","kind":"metric","name":"Successfully included header files"}},{"id":"cpp/telemetry/failed-includes","name":"cpp/telemetry/failed-includes","shortDescription":{"text":"Failed to include header file"},"fullDescription":{"text":"A count of all failed includes, grouped by filename."},"defaultConfiguration":{"enabled":true},"properties":{"tags":["summary","telemetry"],"description":"A count of all failed includes, grouped by filename.","id":"cpp/telemetry/failed-includes","kind":"metric","name":"Failed to include header file"}},{"id":"cpp/telemetry/extraction-metrics","name":"cpp/telemetry/extraction-metrics","shortDescription":{"text":"Extraction metrics"},"fullDescription":{"text":"Raw metrics relating to extraction."},"defaultConfiguration":{"enabled":true},"properties":{"tags":["summary","telemetry"],"description":"Raw metrics relating to extraction.","id":"cpp/telemetry/extraction-metrics","kind":"metric","name":"Extraction metrics"}},{"id":"cpp/summary/lines-of-code","name":"cpp/summary/lines-of-code","shortDescription":{"text":"Total lines of C/C++ code in the database"},"fullDescription":{"text":"The total number of lines of C/C++ code across all files, including system headers, libraries, and auto-generated files. This is a useful metric of the size of a database. For all files that were seen during the build, this query counts the lines of code, excluding whitespace or comments."},"defaultConfiguration":{"enabled":true},"properties":{"tags":["summary","telemetry"],"description":"The total number of lines of C/C++ code across all files, including system headers, libraries, and auto-generated files. This is a useful metric of the size of a database. For all files that were seen during the build, this query counts the lines of code, excluding whitespace or comments.","id":"cpp/summary/lines-of-code","kind":"metric","name":"Total lines of C/C++ code in the database"}},{"id":"cpp/summary/lines-of-user-code","name":"cpp/summary/lines-of-user-code","shortDescription":{"text":"Total lines of user written C/C++ code in the database"},"fullDescription":{"text":"The total number of lines of C/C++ code from the source code directory, excluding auto-generated files. This query counts the lines of code, excluding whitespace or comments. Note: If external libraries are included in the codebase either in a checked-in virtual environment or as vendored code, that will currently be counted as user written code."},"defaultConfiguration":{"enabled":true},"properties":{"tags":["summary","lines-of-code","debug"],"description":"The total number of lines of C/C++ code from the source code directory, excluding auto-generated files. This query counts the lines of code, excluding whitespace or comments. Note: If external libraries are included in the codebase either in a checked-in virtual environment or as vendored code, that will currently be counted as user written code.","id":"cpp/summary/lines-of-user-code","kind":"metric","name":"Total lines of user written C/C++ code in the database"}}],"locations":[{"uri":"file:///opt/hostedtoolcache/CodeQL/2.22.1/x64/codeql/qlpacks/codeql/cpp-queries/1.4.3/","description":{"text":"The QL pack root directory."},"properties":{"tags":["CodeQL/LocalPackRoot"]}},{"uri":"file:///opt/hostedtoolcache/CodeQL/2.22.1/x64/codeql/qlpacks/codeql/cpp-queries/1.4.3/qlpack.yml","description":{"text":"The QL pack definition file."},"properties":{"tags":["CodeQL/LocalPackDefinitionFile"]}}]},{"name":"codeql/cpp-all","semanticVersion":"5.2.0+4ece8abc3032a266eb4b9839442d8be5084552ea","locations":[{"uri":"file:///opt/hostedtoolcache/CodeQL/2.22.1/x64/codeql/qlpacks/codeql/cpp-queries/1.4.3/.codeql/libraries/codeql/cpp-all/5.2.0/","description":{"text":"The QL pack root directory."},"properties":{"tags":["CodeQL/LocalPackRoot"]}},{"uri":"file:///opt/hostedtoolcache/CodeQL/2.22.1/x64/codeql/qlpacks/codeql/cpp-queries/1.4.3/.codeql/libraries/codeql/cpp-all/5.2.0/qlpack.yml","description":{"text":"The QL pack definition file."},"properties":{"tags":["CodeQL/LocalPackDefinitionFile"]}}]}]},"invocations":[{"toolExecutionNotifications":[{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main.cpp","uriBaseId":"%SRCROOT%","index":0}}}],"message":{"text":"File successfully extracted."},"level":"none","descriptor":{"id":"cpp/diagnostics/successfully-extracted-files","index":0,"toolComponent":{"index":0}},"properties":{"formattedMessage":{"text":"File successfully extracted."}}},{"locations":[{"physicalLocation":{"artifactLocation":{"uri":"src/main.cpp","uriBaseId":"%SRCROOT%","index":0}}}],"message":{"text":""},"level":"none","descriptor":{"id":"cli/expected-extracted-files/cpp","index":0},"properties":{"formattedMessage":{"text":""}}},{"message":{"text":""},"level":"none","timeUtc":"2025-07-24T06:51:58.130Z","descriptor":{"id":"codeql-action/zstd-availability","index":1},"properties":{"attributes":{"available":true,"foundZstdBinary":true,"version":{"type":"gnu","version":"1.35"}},"visibility":{"statusPage":false,"telemetry":true}}},{"message":{"text":"Internal telemetry for the C++ extractor.\n\nNo action needed.","markdown":"Internal telemetry for the C++ extractor.\n\nNo action needed."},"level":"note","timeUtc":"2025-07-24T06:52:16.191246Z","descriptor":{"id":"cpp/extractor/summary","index":2},"properties":{"attributes":{"cache-hits":0,"cache-misses":1,"compilers":[{"program":"gcc","version":"x86_64-linux-gnu-g++-13 (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0"},{"program":"gcc-cc1"}],"extractor-failures":0,"extractor-successes":1,"trap-caching":"writing"},"visibility":{"statusPage":false,"telemetry":true}}}],"executionSuccessful":true}],"artifacts":[{"location":{"uri":"src/main.cpp","uriBaseId":"%SRCROOT%","index":0}}],"results":[],"columnKind":"utf16CodeUnits","properties":{"semmle.formatSpecifier":"sarif-latest","metricResults":[{"rule":{"id":"cpp/telemetry/database-quality","index":51,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/database-quality","value":100.0,"message":{"text":"Percentage of functions without errors"}},{"rule":{"id":"cpp/telemetry/database-quality","index":51,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/database-quality","value":100.0,"message":{"text":"Percentage of compilations without errors"}},{"rule":{"id":"cpp/telemetry/database-quality","index":51,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/database-quality","value":100.0,"message":{"text":"Percentage of variables with a known type"}},{"rule":{"id":"cpp/telemetry/database-quality","index":51,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/database-quality","value":100.0,"message":{"text":"Percentage of calls with an explicit target"}},{"rule":{"id":"cpp/telemetry/database-quality","index":51,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/database-quality","value":100.0,"message":{"text":"Percentage of expressions with a known type"}},{"rule":{"id":"cpp/telemetry/database-quality","index":51,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/database-quality","value":100.0,"message":{"text":"Percentage of source/header files without errors"}},{"rule":{"id":"cpp/telemetry/database-quality","index":51,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/database-quality","value":100.0,"message":{"text":"Percentage of successfully resolved #include directives"}},{"rule":{"id":"cpp/telemetry/database-quality","index":51,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/database-quality","value":100.0,"message":{"text":"Percentage of non-error expressions"}},{"rule":{"id":"cpp/telemetry/database-quality","index":51,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/database-quality","value":100.0,"message":{"text":"Percentage of lines of code without errors"}},{"rule":{"id":"cpp/telemetry/succeeded-includes","index":52,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/succeeded-includes","value":1,"message":{"text":"<iostream>"}},{"rule":{"id":"cpp/telemetry/extraction-metrics","index":54,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/extraction-metrics","value":1654,"message":{"text":"calls"}},{"rule":{"id":"cpp/telemetry/extraction-metrics","index":54,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/extraction-metrics","value":4535,"message":{"text":"functions"}},{"rule":{"id":"cpp/telemetry/extraction-metrics","index":54,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/extraction-metrics","value":8174,"message":{"text":"variables"}},{"rule":{"id":"cpp/telemetry/extraction-metrics","index":54,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/extraction-metrics","value":22058,"message":{"text":"expressions"}},{"rule":{"id":"cpp/telemetry/extraction-metrics","index":54,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/extraction-metrics","value":1,"message":{"text":"compilations"}},{"rule":{"id":"cpp/telemetry/extraction-metrics","index":54,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/extraction-metrics","value":0,"message":{"text":"syntax errors"}},{"rule":{"id":"cpp/telemetry/extraction-metrics","index":54,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/extraction-metrics","value":0,"message":{"text":"compiler errors"}},{"rule":{"id":"cpp/telemetry/extraction-metrics","index":54,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/extraction-metrics","value":195,"message":{"text":"source/header files"}},{"rule":{"id":"cpp/telemetry/extraction-metrics","index":54,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/extraction-metrics","value":39625,"message":{"text":"lines of code"}},{"rule":{"id":"cpp/telemetry/extraction-metrics","index":54,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/extraction-metrics","value":65366,"message":{"text":"lines of text"}},{"rule":{"id":"cpp/telemetry/extraction-metrics","index":54,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/extraction-metrics","value":4535,"message":{"text":"functions without errors"}},{"rule":{"id":"cpp/telemetry/extraction-metrics","index":54,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/extraction-metrics","value":1,"message":{"text":"compilations without errors"}},{"rule":{"id":"cpp/telemetry/extraction-metrics","index":54,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/extraction-metrics","value":8174,"message":{"text":"variables with a known type"}},{"rule":{"id":"cpp/telemetry/extraction-metrics","index":54,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/extraction-metrics","value":1654,"message":{"text":"calls with an explicit target"}},{"rule":{"id":"cpp/telemetry/extraction-metrics","index":54,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/extraction-metrics","value":22058,"message":{"text":"expressions with a known type"}},{"rule":{"id":"cpp/telemetry/extraction-metrics","index":54,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/extraction-metrics","value":195,"message":{"text":"source/header files without errors"}},{"rule":{"id":"cpp/telemetry/extraction-metrics","index":54,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/extraction-metrics","value":457,"message":{"text":"successfully resolved #include directives"}},{"rule":{"id":"cpp/telemetry/extraction-metrics","index":54,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/extraction-metrics","value":457,"message":{"text":"#include directives"}},{"rule":{"id":"cpp/telemetry/extraction-metrics","index":54,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/extraction-metrics","value":22058,"message":{"text":"non-error expressions"}},{"rule":{"id":"cpp/telemetry/extraction-metrics","index":54,"toolComponent":{"index":0}},"ruleId":"cpp/telemetry/extraction-metrics","value":39625,"message":{"text":"lines of code without errors"}},{"rule":{"id":"cpp/summary/lines-of-code","index":55,"toolComponent":{"index":0}},"ruleId":"cpp/summary/lines-of-code","value":39625},{"rule":{"id":"cpp/summary/lines-of-user-code","index":56,"toolComponent":{"index":0}},"ruleId":"cpp/summary/lines-of-user-code","value":5,"baseline":5}],"codeqlConfigSummary":{"disableDefaultQueries":false},"jobRunUuid":"8cbb91bd-200e-426e-96d4-630409506248"}}]}